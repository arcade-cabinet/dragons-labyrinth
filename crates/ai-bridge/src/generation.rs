//! Asset generation types and results

use std::path::PathBuf;
use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use serde_json::Value;

/// Generation request for an asset
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GenerationRequest {
    /// Type of asset to generate
    pub asset_type: String,
    
    /// Horror progression level (0-4)
    pub dread_level: u8,
    
    /// Detailed description of what to generate
    pub description: String,
    
    /// Additional requirements and metadata
    pub requirements: HashMap<String, Value>,
    
    /// Whether to check cache first
    pub use_cache: bool,
    
    /// Whether to search existing assets first
    pub search_existing: bool,
}

impl GenerationRequest {
    /// Create a new generation request
    pub fn new(asset_type: impl Into<String>, dread_level: u8, description: impl Into<String>) -> Self {
        Self {
            asset_type: asset_type.into(),
            dread_level,
            description: description.into(),
            requirements: HashMap::new(),
            use_cache: true,
            search_existing: true,
        }
    }
    
    /// Add a requirement
    pub fn with_requirement(mut self, key: impl Into<String>, value: Value) -> Self {
        self.requirements.insert(key.into(), value);
        self
    }
    
    /// Disable cache usage
    pub fn without_cache(mut self) -> Self {
        self.use_cache = false;
        self
    }
    
    /// Disable existing asset search
    pub fn without_search(mut self) -> Self {
        self.search_existing = false;
        self
    }
}

/// Result of a generation request
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GenerationResult {
    /// Whether generation was successful
    pub success: bool,
    
    /// Unique asset ID
    pub asset_id: String,
    
    /// Files that were generated
    pub output_files: Vec<PathBuf>,
    
    /// Additional metadata about the generation
    pub metadata: HashMap<String, Value>,
    
    /// Source of the asset
    pub source: AssetSource,
    
    /// Warnings or notes
    pub warnings: Vec<String>,
}

impl GenerationResult {
    /// Create a successful generation result
    pub fn success(asset_id: impl Into<String>) -> Self {
        Self {
            success: true,
            asset_id: asset_id.into(),
            output_files: Vec::new(),
            metadata: HashMap::new(),
            source: AssetSource::Generated,
            warnings: Vec::new(),
        }
    }
    
    /// Create a failed generation result
    pub fn failure(asset_id: impl Into<String>, reason: impl Into<String>) -> Self {
        let reason_str = reason.into();
        let mut result = Self {
            success: false,
            asset_id: asset_id.into(),
            output_files: Vec::new(),
            metadata: HashMap::new(),
            source: AssetSource::Failed,
            warnings: vec![reason_str.clone()],
        };
        result.metadata.insert("failure_reason".to_string(), Value::String(reason_str));
        result
    }
    
    /// Add an output file
    pub fn with_output_file(mut self, path: PathBuf) -> Self {
        self.output_files.push(path);
        self
    }
    
    /// Add metadata
    pub fn with_metadata(mut self, key: impl Into<String>, value: Value) -> Self {
        self.metadata.insert(key.into(), value);
        self
    }
    
    /// Set the asset source
    pub fn with_source(mut self, source: AssetSource) -> Self {
        self.source = source;
        self
    }
    
    /// Add a warning
    pub fn with_warning(mut self, warning: impl Into<String>) -> Self {
        self.warnings.push(warning.into());
        self
    }
}

/// Source of an asset
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum AssetSource {
    /// Found in CC0 library
    Library,
    
    /// Retrieved from cache
    Cached,
    
    /// Generated by AI
    Generated,
    
    /// Enhanced existing asset
    Enhanced,
    
    /// Generation failed
    Failed,
}

/// Asset generation statistics
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct GenerationStats {
    /// Total requests
    pub total_requests: usize,
    
    /// Successful generations
    pub successful: usize,
    
    /// Failed generations
    pub failed: usize,
    
    /// Assets found in library
    pub from_library: usize,
    
    /// Assets retrieved from cache
    pub from_cache: usize,
    
    /// Assets generated by AI
    pub ai_generated: usize,
    
    /// Assets enhanced from existing
    pub enhanced: usize,
    
    /// Total API tokens used
    pub tokens_used: usize,
    
    /// Total generation time in seconds
    pub total_time_seconds: f64,
}

impl GenerationStats {
    /// Record a generation result
    pub fn record(&mut self, result: &GenerationResult, tokens: usize, time_seconds: f64) {
        self.total_requests += 1;
        self.tokens_used += tokens;
        self.total_time_seconds += time_seconds;
        
        if result.success {
            self.successful += 1;
            match result.source {
                AssetSource::Library => self.from_library += 1,
                AssetSource::Cached => self.from_cache += 1,
                AssetSource::Generated => self.ai_generated += 1,
                AssetSource::Enhanced => self.enhanced += 1,
                AssetSource::Failed => {} // Shouldn't happen with success=true
            }
        } else {
            self.failed += 1;
        }
    }
    
    /// Get success rate
    pub fn success_rate(&self) -> f64 {
        if self.total_requests == 0 {
            0.0
        } else {
            self.successful as f64 / self.total_requests as f64
        }
    }
    
    /// Get cache hit rate
    pub fn cache_hit_rate(&self) -> f64 {
        if self.total_requests == 0 {
            0.0
        } else {
            self.from_cache as f64 / self.total_requests as f64
        }
    }
    
    /// Get library reuse rate
    pub fn library_reuse_rate(&self) -> f64 {
        if self.total_requests == 0 {
            0.0
        } else {
            (self.from_library + self.from_cache) as f64 / self.total_requests as f64
        }
    }
    
    /// Get average generation time
    pub fn average_time_seconds(&self) -> f64 {
        if self.total_requests == 0 {
            0.0
        } else {
            self.total_time_seconds / self.total_requests as f64
        }
    }
}

/// Batch generation request
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BatchGenerationRequest {
    /// Requests to process
    pub requests: Vec<GenerationRequest>,
    
    /// Whether to process in parallel
    pub parallel: bool,
    
    /// Maximum concurrent requests
    pub max_concurrent: usize,
    
    /// Whether to stop on first failure
    pub stop_on_failure: bool,
}

impl BatchGenerationRequest {
    /// Create a new batch request
    pub fn new(requests: Vec<GenerationRequest>) -> Self {
        Self {
            requests,
            parallel: true,
            max_concurrent: 4,
            stop_on_failure: false,
        }
    }
    
    /// Process sequentially
    pub fn sequential(mut self) -> Self {
        self.parallel = false;
        self
    }
    
    /// Set max concurrent requests
    pub fn with_max_concurrent(mut self, max: usize) -> Self {
        self.max_concurrent = max;
        self
    }
    
    /// Stop on first failure
    pub fn stop_on_failure(mut self) -> Self {
        self.stop_on_failure = true;
        self
    }
}

/// Batch generation result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BatchGenerationResult {
    /// Individual results
    pub results: Vec<GenerationResult>,
    
    /// Total successes
    pub successes: usize,
    
    /// Total failures
    pub failures: usize,
    
    /// Overall statistics
    pub stats: GenerationStats,
    
    /// Whether batch was stopped early
    pub stopped_early: bool,
}

impl BatchGenerationResult {
    /// Create from individual results
    pub fn from_results(results: Vec<GenerationResult>) -> Self {
        let successes = results.iter().filter(|r| r.success).count();
        let failures = results.len() - successes;
        
        Self {
            results,
            successes,
            failures,
            stats: GenerationStats::default(),
            stopped_early: false,
        }
    }
    
    /// Check if all succeeded
    pub fn all_succeeded(&self) -> bool {
        self.failures == 0
    }
    
    /// Get success rate
    pub fn success_rate(&self) -> f64 {
        let total = self.successes + self.failures;
        if total == 0 {
            0.0
        } else {
            self.successes as f64 / total as f64
        }
    }
}
