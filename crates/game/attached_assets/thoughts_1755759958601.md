Dragon's Labyrinth – Bevy Implementation

This repository contains the source code and design documents for **Dragon's Labyrinth**, a horror‑first role‑playing game generated entirely from AI prompts.  The original concept targeted the Godot engine; this Bevy version reimagines the project to better align with a fully automated generation pipeline while preserving the core narrative and experiential goals.

Dragon's Labyrinth follows a young villager whose idyllic world gradually decays into unease, dread and terror as they venture from their village, through twisted biomes, and into the ruins guarded by an ancient dragon.  The player’s choices — compassion versus cruelty, loyalty versus self‑interest — shape both the world and the character’s identity.  The game is about **experiencing the journey**, not simply completing quests.

## Why Bevy?

The Godot engine was originally chosen because of its strong 2D features.  However, the **AI‑only generation constraint** highlighted limitations in Godot’s tooling and import pipeline.  In particular, Godot’s scene and resource formats are verbose and require manual editing to integrate generated content.  The Rust ecosystem, via **Bevy**, provides:

- A modern, data‑driven **Entity Component System (ECS)** architecture that maps naturally to AI‑generated components.
- The ability to **compile the same executable** into either game or level editor mode using the [`bevy‑yoleck`](https://docs.rs/bevy_yoleck/latest/bevy_yoleck/) plugin.  Levels are stored as JSON (`.yol`) files and edited via egui widgets【753497817757051†L104-L115】.
- A declarative UI framework via **Cobweb** and **Cobweb UI**.  Cobweb exposes reactivity primitives such as reactions to resource mutations and system events【807230068843399†L268-L277】, while Cobweb UI provides a **COB scene format**, localisation support and built‑in widgets for menus, inventories and dialogues【368625877675928†L279-L286】.  These are ideal for AI‑generated user interfaces.
- **Hexx**, a library for manipulating hex grids and computing distances, rings, ranges, paths and line of sight【965189013564942†L70-L74】【965189013564942†L80-L101】.  Hexx also offers optional mesh generation for hex columns and height maps【965189013564942†L245-L262】.
- **Yarn Spinner for Rust**, integrated via the `bevy_yarnspinner` crate.  It compiles `.yarn` dialogue files into a `YarnProject` resource and provides a `DialogueRunner` component that emits events for custom dialogue views【718529118110301†L98-L129】.  This suits our narrative‑heavy design.

By leveraging these crates, we can build a Bevy game where every asset and piece of code – levels, characters, dialogues, tests, mounts – is generated by AI and integrated deterministically.

## Core Design Principles

1. **Horror‑First Narrative:**  The game isn’t “an RPG with horror elements”; it is a horror experience with RPG mechanics.  The emotional arc drives every system.  Players feel the peace of the village, the unease of the journey, the dread of the labyrinth, the terror of the dragon, and the final horror of the void beyond.
2. **Zero External Dependencies:**  No purchased asset packs or third‑party libraries beyond open‑source crates.  All art, audio and code are generated from prompts.
3. **Idempotent Generation:**  Running the generator twice with the same inputs produces identical outputs.  Stable IDs, sorted collections and deterministic hashing underpin this.
4. **Component Independence:**  Systems are composed of small, focused components.  They communicate via events and resources, never through global state.
5. **Performance by Design:**  The entire game must run at 60 FPS on desktop and 30 FPS on mid‑range mobile devices.  We use asynchronous asset loading, chunked rendering and efficient pathfinding to meet budgets.

## Story & Gameplay Overview

### Opening & Village

The game begins in first person as the player opens the door of their cottage to a sunlit village.  This is the only first‑person moment; it frames the emotional baseline.  Immediately after, the camera pulls up into an **isometric view** of the village board.  Villagers mill about; children play near the well.  The player learns movement and interactions.

### The Journey Outward

The protagonist undertakes tasks on behalf of the villagers – collecting herbs, delivering bread – while the world subtly darkens.  Birds stop singing; whispers rise.  The game transitions through **peace → unease → dread**.  **Tests of Strength** emphasise party coordination: hold off creatures or navigate collapsing ground.  **Tests of Harmony** emphasise attunement with companions: align chords, match breaths.  Each test uses the same board engine with special overlays and rules.  Failing tests reduces sanity; passing earns traits and gear.

### The Labyrinth & Terror

The dragon’s labyrinth is introduced not through free‑look 3D but via **setpiece boards**.  A player clicks a labyrinth entrance on the overworld board; the camera zooms to a high‑resolution hex scene showing twisting walls, dark alcoves and traps.  Here, Tests of Strength become survival gauntlets; Tests of Harmony become sanity battles.  **Mounts** such as seastriders or rock crushers grant temporary traversal over water or lava, their auras modifying path costs and surfaces based on alignment.

### Beyond the Dragon

Upon defeating the dragon, the player discovers the dragon was guarding something worse: creatures from the void.  The journey back to the village is a reverse of the descent – the world is now twisted; survivors are few.  The final act is the **ultimate test**: will the player embrace darkness for power or sacrifice themselves to seal the void?  Dialogue choices and earlier traits determine multiple endings.

## Technical Implementation

### Board Rendering

Instead of tiling small images, each board (village, forest, crypt, labyrinth room, void field) is rendered as a **beauty texture** and a set of control maps:

- **Albedo textures** for materials (grass, dirt, sand, rock, water, lava).  These are seamlessly tiling PNGs generated from AI prompts.
- **Splatmaps** (RGBA) where each channel encodes the weight of a material at each pixel.  The splatmap is generated based on procedural rules (paths, clearings, ponds) and can include per‑stage variants (peace, unease, dread).  A fragment shader blends the four materials by their weights.
- **Overlay masks** for roads, bridges and hazards.  Overlays can override walkability (e.g., a bridge can override a water tile) and apply separate costs.
- **ID maps** where reserved colours mark interactive objects (doors, wells, altars) and test entry points.  An accompanying JSON lists each object’s name, position and tags.

Bevy systems load these textures, build a navigation grid via Hexx for A* pathfinding and field‑of‑view, and spawn interactive markers at object positions.

### Level Editing

Using `bevy_yoleck`, the same game binary can switch into editor mode.  In this mode, Yoleck loads `.yol` files that describe entities (tiles, props, spawns) as JSON tuples.  Entities can be moved and their data edited with `egui` widgets【753497817757051†L104-L115】.  This allows the AI director to emit new `.yol` files for levels and immediately test them in engine.

### User Interface

All UI (HUD, menus, inventory, dialogue boxes) is built using **Cobweb UI**’s COB format【368625877675928†L279-L286】.  The AI emits `.cob` scene files describing layouts, widget types, colours and animations.  Cobweb UI’s localisation framework supports multiple languages.

### Dialogue

Dialogue is authored in Yarn.  The `bevy_yarnspinner` plugin compiles `.yarn` files into a `YarnProject` resource at load time【718529118110301†L98-L112】.  A `DialogueRunner` component steps through lines and sends events; custom dialogue views implemented with Cobweb UI handle displaying text and options and call `continue_in_next_update()` or `select_option()` to advance【718529118110301†L114-L129】.

### Hex Grid & Pathfinding

Gameplay uses axial hex coordinates via **Hexx**.  Hexx provides conversions, neighbours, distances, rings and lines【965189013564942†L80-L101】.  The optional `algorithms` module enables field‑of‑movement, A* pathfinding and field‑of‑view【965189013564942†L70-L74】.  These algorithms power movement, detection and AI behaviours.  The board’s cost grid is derived from the splatmap and overlays, with mount auras temporarily overriding local costs.

### Mount System

Mounts project an aura that modifies terrain costs.  Each mount has a capability table specifying how it interacts with surfaces (water, lava, swamp).  As a mount bonds with the player (good alignment) or is enslaved (evil alignment), the aura grows and can override blocked cells.  Mount data is stored in JSON and applied at runtime by a system that modifies the cost field inside the aura region.

### Tests of Strength, Harmony and Morality

Special encounters are implemented as **setpiece boards**.  When the player clicks a ritual hex or enters a cave, a system zooms to a high‑resolution board where a mini‑game runs.  Tests of Strength involve tactical positioning and timed waves; Tests of Harmony require synchronising inputs; Moral Tests offer the same mechanics but with different rewards or consequences based on alignment.  Each setpiece defines rules, assets and scripts in JSON and Rust modules.