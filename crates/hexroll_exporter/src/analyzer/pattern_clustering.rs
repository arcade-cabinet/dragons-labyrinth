//! HTML pattern clustering and semantic analysis for efficient batch processing of 70k+ entities

use anyhow::Result;
use rusqlite::Connection;
use std::collections::HashMap;
use serde::{Deserialize, Serialize};

use super::types::{AnalysisReport, TableInfo};

/// AI-enhanced analysis result for pattern clusters
#[derive(Debug, Clone)]
pub struct AIEnhancedAnalysis {
    pub enhanced_orm_model: String,
    pub enhanced_transformation_pipeline: String,
    pub discovered_relationships: Vec<super::types::DiscoveredRelationship>,
}

/// HTML pattern clustering engine for finding commonalities across 70k entities
pub struct PatternClusteringEngine;

impl PatternClusteringEngine {
    /// Analyze HTML patterns across ALL entities to find commonalities for batch processing
    pub fn analyze_html_pattern_clusters(conn: &Connection, report: &mut AnalysisReport) -> Result<Vec<HTMLPatternCluster>> {
        println!("ðŸ” Analyzing HTML patterns across ALL 70k+ entities for clustering...");
        
        let mut clusters = Vec::new();
        
        for (table_name, table_info) in &report.table_info {
            if table_info.record_count > 1000 { // Focus on large tables
                println!("   ðŸ“Š Clustering patterns in {} ({} records)", table_name, table_info.record_count);
                
                let table_clusters = Self::cluster_table_patterns(conn, table_name, table_info)?;
                clusters.extend(table_clusters);
            }
        }
        
        // Merge similar clusters across tables
        let merged_clusters = Self::merge_similar_clusters(clusters)?;
        
        println!("âœ… Found {} distinct HTML pattern clusters for efficient batch processing", merged_clusters.len());
        
        Ok(merged_clusters)
    }
    
    /// Cluster HTML patterns within a single table
    fn cluster_table_patterns(conn: &Connection, table_name: &str, table_info: &TableInfo) -> Result<Vec<HTMLPatternCluster>> {
        let mut clusters = Vec::new();
        
        // Find text columns for HTML analysis
        let text_columns: Vec<_> = table_info.columns.iter()
            .filter(|col| col.data_type.to_uppercase().contains("TEXT"))
            .collect();
        
        for column in text_columns {
            println!("      ðŸ” Analyzing {}.{} for HTML patterns...", table_name, column.name);
            
            // Get HTML pattern distribution across the entire column
            let pattern_distribution = Self::analyze_html_pattern_distribution(conn, table_name, &column.name)?;
            
            // Create clusters based on HTML structure similarity
            for (pattern_signature, entities) in pattern_distribution {
                if entities.count > 10 { // Only cluster patterns with sufficient examples
                    let examples_clone = entities.examples.clone();
                    clusters.push(HTMLPatternCluster {
                        cluster_id: format!("{}_{}_cluster_{}", table_name, column.name, pattern_signature),
                        table_name: table_name.to_string(),
                        column_name: column.name.clone(),
                        pattern_signature,
                        entity_count: entities.count,
                        example_entities: entities.examples,
                        html_structure: entities.structure_analysis,
                        semantic_tags: Self::extract_semantic_tags(&examples_clone),
                        processing_template: None, // Will be generated by AI
                    });
                }
            }
        }
        
        Ok(clusters)
    }
    
    /// Analyze HTML pattern distribution across an entire column
    fn analyze_html_pattern_distribution(conn: &Connection, table_name: &str, column_name: &str) -> Result<HashMap<String, ClusterInfo>> {
        let mut pattern_map = HashMap::new();
        
        // Query to get ALL HTML content for pattern analysis
        let query = format!(
            "SELECT {}, SUBSTR({}, 1, 500) as content_preview FROM {} WHERE {} IS NOT NULL AND LENGTH({}) > 20",
            column_name, column_name, table_name, column_name, column_name
        );
        
        let mut stmt = conn.prepare(&query)?;
        let rows = stmt.query_map([], |row| {
            let content: String = row.get(0)?;
            let preview: String = row.get(1)?;
            Ok((content, preview))
        })?;
        
        for row in rows {
            let (content, preview) = row?;
            let signature = Self::generate_html_signature(&content);
            
            let cluster_info = pattern_map.entry(signature).or_insert_with(|| ClusterInfo {
                count: 0,
                examples: Vec::new(),
                structure_analysis: String::new(),
            });
            
            cluster_info.count += 1;
            if cluster_info.examples.len() < 5 {
                cluster_info.examples.push(preview);
            }
        }
        
        // Generate structure analysis for each pattern
        for (signature, cluster_info) in &mut pattern_map {
            cluster_info.structure_analysis = Self::analyze_html_structure(&cluster_info.examples);
            println!("        ðŸ“‹ Pattern {}: {} entities ({})", 
                     signature, cluster_info.count, cluster_info.structure_analysis);
        }
        
        Ok(pattern_map)
    }
    
    /// Generate HTML signature for clustering similar structures
    fn generate_html_signature(html_content: &str) -> String {
        let mut signature_parts = Vec::new();
        
        // Analyze HTML structure patterns
        if html_content.contains("<table") {
            signature_parts.push("table");
        }
        if html_content.contains("<div") {
            signature_parts.push("div");
        }
        if html_content.contains("<ul") || html_content.contains("<ol") {
            signature_parts.push("list");
        }
        if html_content.contains("<h1") || html_content.contains("<h2") || html_content.contains("<h3") {
            signature_parts.push("headers");
        }
        if html_content.contains("<p>") {
            signature_parts.push("paragraphs");
        }
        if html_content.contains("<a href=") {
            signature_parts.push("links");
        }
        if html_content.contains("class=") {
            signature_parts.push("styled");
        }
        
        // Add content length category
        let length_category = match html_content.len() {
            0..=100 => "short",
            101..=500 => "medium", 
            501..=2000 => "long",
            _ => "very_long",
        };
        signature_parts.push(length_category);
        
        // Add semantic hints from content
        let content_lower = html_content.to_lowercase();
        if content_lower.contains("village") || content_lower.contains("town") || content_lower.contains("city") {
            signature_parts.push("settlement");
        }
        if content_lower.contains("dungeon") || content_lower.contains("cave") || content_lower.contains("tomb") {
            signature_parts.push("dungeon");
        }
        if content_lower.contains("npc") || content_lower.contains("character") || content_lower.contains("person") {
            signature_parts.push("character");
        }
        if content_lower.contains("item") || content_lower.contains("weapon") || content_lower.contains("armor") {
            signature_parts.push("item");
        }
        if content_lower.contains("faction") || content_lower.contains("guild") || content_lower.contains("cult") {
            signature_parts.push("organization");
        }
        
        signature_parts.sort();
        signature_parts.join("_")
    }
    
    /// Analyze HTML structure for a cluster
    fn analyze_html_structure(examples: &[String]) -> String {
        let mut analysis = Vec::new();
        
        // Count common elements across examples
        let mut element_counts = HashMap::new();
        for example in examples {
            for element in ["table", "div", "ul", "ol", "h1", "h2", "h3", "p", "a", "span", "strong", "em"] {
                if example.contains(&format!("<{}", element)) {
                    *element_counts.entry(element).or_insert(0) += 1;
                }
            }
        }
        
        // Find dominant patterns
        for (element, count) in element_counts {
            if count > examples.len() / 2 {
                analysis.push(format!("{}({})", element, count));
            }
        }
        
        if analysis.is_empty() {
            "text_content".to_string()
        } else {
            analysis.join("+")
        }
    }
    
    /// Extract semantic tags from content examples
    fn extract_semantic_tags(examples: &[String]) -> Vec<String> {
        let mut tags = Vec::new();
        let mut tag_counts = HashMap::new();
        
        for example in examples {
            let content_lower = example.to_lowercase();
            
            // Entity type detection
            for (tag, keywords) in [
                ("settlement", vec!["village", "town", "city", "outpost", "hamlet"]),
                ("dungeon", vec!["dungeon", "cave", "tomb", "crypt", "lair"]),
                ("character", vec!["npc", "character", "person", "merchant", "guard"]),
                ("item", vec!["item", "weapon", "armor", "treasure", "artifact"]),
                ("organization", vec!["faction", "guild", "cult", "militia", "order"]),
                ("location", vec!["location", "place", "area", "region", "landmark"]),
                ("quest", vec!["quest", "mission", "task", "objective", "goal"]),
                ("lore", vec!["history", "legend", "story", "tale", "lore"]),
            ] {
                for keyword in keywords {
                    if content_lower.contains(keyword) {
                        *tag_counts.entry(tag.to_string()).or_insert(0) += 1;
                        break;
                    }
                }
            }
        }
        
        // Include tags that appear in multiple examples
        for (tag, count) in tag_counts {
            if count > 1 {
                tags.push(tag);
            }
        }
        
        tags.sort();
        tags
    }
    
    /// Merge similar clusters across tables for efficiency
    fn merge_similar_clusters(clusters: Vec<HTMLPatternCluster>) -> Result<Vec<HTMLPatternCluster>> {
        let mut merged = Vec::new();
        let mut processed = std::collections::HashSet::new();
        
        for cluster in &clusters {
            if processed.contains(&cluster.cluster_id) {
                continue;
            }
            
            // Find similar clusters
            let mut similar_clusters = vec![cluster];
            for other_cluster in &clusters {
                if other_cluster.cluster_id != cluster.cluster_id && 
                   Self::clusters_are_similar(&cluster, &other_cluster) {
                    similar_clusters.push(other_cluster);
                    processed.insert(other_cluster.cluster_id.clone());
                }
            }
            
            // Merge similar clusters
            if similar_clusters.len() > 1 {
                let merged_cluster = Self::merge_cluster_group(similar_clusters)?;
                merged.push(merged_cluster);
            } else {
                merged.push(cluster.clone());
            }
            
            processed.insert(cluster.cluster_id.clone());
        }
        
        Ok(merged)
    }
    
    /// Check if two clusters have similar patterns
    fn clusters_are_similar(cluster1: &HTMLPatternCluster, cluster2: &HTMLPatternCluster) -> bool {
        // Similar if they share semantic tags or HTML structure
        let shared_tags = cluster1.semantic_tags.iter()
            .filter(|tag| cluster2.semantic_tags.contains(tag))
            .count();
        
        shared_tags > 0 || cluster1.html_structure == cluster2.html_structure
    }
    
    /// Merge a group of similar clusters
    fn merge_cluster_group(clusters: Vec<&HTMLPatternCluster>) -> Result<HTMLPatternCluster> {
        let first = clusters[0];
        let total_entities: usize = clusters.iter().map(|c| c.entity_count).sum();
        
        let mut all_examples = Vec::new();
        let mut all_tags = Vec::new();
        
        for cluster in clusters {
            all_examples.extend(cluster.example_entities.clone());
            all_tags.extend(cluster.semantic_tags.clone());
        }
        
        all_tags.sort();
        all_tags.dedup();
        
        Ok(HTMLPatternCluster {
            cluster_id: format!("merged_{}", first.pattern_signature),
            table_name: "multiple".to_string(),
            column_name: "multiple".to_string(),
            pattern_signature: first.pattern_signature.clone(),
            entity_count: total_entities,
            example_entities: all_examples.into_iter().take(10).collect(),
            html_structure: first.html_structure.clone(),
            semantic_tags: all_tags,
            processing_template: None,
        })
    }
}

/// HTML pattern cluster representing similar entity types
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HTMLPatternCluster {
    pub cluster_id: String,
    pub table_name: String,
    pub column_name: String,
    pub pattern_signature: String,
    pub entity_count: usize,
    pub example_entities: Vec<String>,
    pub html_structure: String,
    pub semantic_tags: Vec<String>,
    pub processing_template: Option<String>,
}

/// Cluster information for pattern analysis
#[derive(Debug, Clone)]
struct ClusterInfo {
    count: usize,
    examples: Vec<String>,
    structure_analysis: String,
}

/// AI-powered batch processing engine for efficient 70k entity processing
pub struct BatchProcessingEngine;

impl BatchProcessingEngine {
    /// Generate AI-powered processing strategies for each pattern cluster
    pub async fn generate_ai_enhanced_batch_strategies(
        clusters: &[HTMLPatternCluster]
    ) -> Result<Vec<BatchProcessingStrategy>> {
        println!("ðŸ¤– Generating AI-enhanced batch processing strategies for {} pattern clusters...", clusters.len());
        
        // Initialize AI integration
        let mut ai_engine = match super::ai_integration::AIAnalysisEngine::new("agent.toml").await {
            Ok(engine) => Some(engine),
            Err(e) => {
                println!("   âš ï¸  AI integration unavailable: {}", e);
                println!("   ðŸ“‹ Falling back to pattern-based strategy generation");
                None
            }
        };
        
        let mut strategies = Vec::new();
        
        for cluster in clusters {
            println!("   ðŸ—ï¸  Strategy for cluster: {} ({} entities)", 
                     cluster.cluster_id, cluster.entity_count);
            
            let strategy = if let Some(ref mut ai) = ai_engine {
                Self::create_ai_enhanced_strategy_for_cluster(cluster, ai).await?
            } else {
                Self::create_processing_strategy_for_cluster(cluster).await?
            };
            strategies.push(strategy);
        }
        
        println!("âœ… Generated {} AI-enhanced batch processing strategies for 70k+ entities", strategies.len());
        Ok(strategies)
    }
    
    /// Create AI-enhanced processing strategy for a specific pattern cluster
    async fn create_ai_enhanced_strategy_for_cluster(
        cluster: &HTMLPatternCluster, 
        ai_engine: &mut super::ai_integration::AIAnalysisEngine
    ) -> Result<BatchProcessingStrategy> {
        println!("      ðŸ¤– AI analyzing cluster patterns for rich template generation...");
        
        // Prepare cluster content for AI analysis
        let cluster_content = Self::prepare_cluster_content_for_ai(cluster)?;
        
        // Use AI to analyze and generate enhanced models
        let ai_analysis = Self::run_ai_analysis_for_cluster(ai_engine, cluster, &cluster_content).await?;
        
        // Create enhanced strategy with AI-generated templates
        Ok(BatchProcessingStrategy {
            cluster_id: cluster.cluster_id.clone(),
            strategy_type: Self::determine_ai_enhanced_strategy_type(cluster, &ai_analysis),
            entity_count: cluster.entity_count,
            orm_model: ai_analysis.enhanced_orm_model,
            transformation_pipeline: ai_analysis.enhanced_transformation_pipeline,
            batch_size: Self::calculate_optimal_batch_size(cluster.entity_count),
            estimated_processing_time: Self::estimate_processing_time(cluster.entity_count),
            semantic_tags: cluster.semantic_tags.clone(),
        })
    }
    
    /// Generate processing strategies for each pattern cluster
    pub async fn generate_batch_processing_strategies(
        clusters: &[HTMLPatternCluster]
    ) -> Result<Vec<BatchProcessingStrategy>> {
        // Use AI-enhanced generation if available, fallback to basic generation
        Self::generate_ai_enhanced_batch_strategies(clusters).await
    }
    
    /// Create processing strategy for a specific pattern cluster
    async fn create_processing_strategy_for_cluster(cluster: &HTMLPatternCluster) -> Result<BatchProcessingStrategy> {
        // Analyze the cluster to determine the best processing approach
        let strategy_type = Self::determine_strategy_type(cluster);
        let orm_model = Self::design_orm_model_for_cluster(cluster)?;
        let transformation_pipeline = Self::design_transformation_pipeline(cluster)?;
        
        Ok(BatchProcessingStrategy {
            cluster_id: cluster.cluster_id.clone(),
            strategy_type,
            entity_count: cluster.entity_count,
            orm_model,
            transformation_pipeline,
            batch_size: Self::calculate_optimal_batch_size(cluster.entity_count),
            estimated_processing_time: Self::estimate_processing_time(cluster.entity_count),
            semantic_tags: cluster.semantic_tags.clone(),
        })
    }
    
    /// Determine the best processing strategy for a cluster
    fn determine_strategy_type(cluster: &HTMLPatternCluster) -> BatchStrategyType {
        if cluster.html_structure.contains("table") {
            BatchStrategyType::StructuredTableParsing
        } else if cluster.html_structure.contains("list") {
            BatchStrategyType::ListItemExtraction
        } else if cluster.html_structure.contains("links") {
            BatchStrategyType::LinkRelationshipMapping
        } else if cluster.semantic_tags.contains(&"settlement".to_string()) {
            BatchStrategyType::SettlementProcessing
        } else if cluster.semantic_tags.contains(&"character".to_string()) {
            BatchStrategyType::CharacterProcessing
        } else {
            BatchStrategyType::GenericTextProcessing
        }
    }
    
    /// Design ORM model for a specific cluster
    fn design_orm_model_for_cluster(cluster: &HTMLPatternCluster) -> Result<String> {
        // Generate SeaORM model based on cluster characteristics
        let model_name = Self::generate_model_name(&cluster.semantic_tags);
        
        let mut model = format!("use sea_orm::entity::prelude::*;\n\n");
        model.push_str(&format!("#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]\n"));
        model.push_str(&format!("#[sea_orm(table_name = \"{}\")]\n", cluster.table_name));
        model.push_str(&format!("pub struct Model {{\n"));
        model.push_str("    #[sea_orm(primary_key)]\n");
        model.push_str("    pub id: i32,\n");
        model.push_str("    pub uuid: String,\n");
        
        // Add fields based on semantic tags
        for tag in &cluster.semantic_tags {
            match tag.as_str() {
                "settlement" => {
                    model.push_str("    pub name: String,\n");
                    model.push_str("    pub settlement_type: Option<String>,\n");
                    model.push_str("    pub population: Option<i32>,\n");
                    model.push_str("    pub description_html: Option<String>,\n");
                }
                "character" => {
                    model.push_str("    pub name: String,\n");
                    model.push_str("    pub character_class: Option<String>,\n");
                    model.push_str("    pub background: Option<String>,\n");
                    model.push_str("    pub description_html: Option<String>,\n");
                }
                "item" => {
                    model.push_str("    pub name: String,\n");
                    model.push_str("    pub item_type: Option<String>,\n");
                    model.push_str("    pub rarity: Option<String>,\n");
                    model.push_str("    pub description_html: Option<String>,\n");
                }
                _ => {}
            }
        }
        
        // Always include raw HTML for complex processing
        model.push_str("    pub raw_html_content: Option<String>,\n");
        model.push_str("}\n\n");
        
        // Add relationships and entity traits
        model.push_str("#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\n");
        model.push_str("pub enum Relation {}\n\n");
        model.push_str("impl ActiveModelBehavior for ActiveModel {}\n");
        
        Ok(model)
    }
    
    /// Generate model name from semantic tags
    fn generate_model_name(semantic_tags: &[String]) -> String {
        if semantic_tags.is_empty() {
            "GenericEntity".to_string()
        } else {
            format!("{}Entity", 
                    semantic_tags[0].chars()
                        .next().unwrap().to_uppercase()
                        .chain(semantic_tags[0].chars().skip(1))
                        .collect::<String>())
        }
    }
    
    /// Design transformation pipeline for cluster
    fn design_transformation_pipeline(cluster: &HTMLPatternCluster) -> Result<String> {
        let mut pipeline = String::new();
        
        pipeline.push_str("// Transformation pipeline for cluster: ");
        pipeline.push_str(&cluster.cluster_id);
        pipeline.push_str("\n");
        pipeline.push_str("// Entity count: ");
        pipeline.push_str(&cluster.entity_count.to_string());
        pipeline.push_str("\n");
        pipeline.push_str("// HTML structure: ");
        pipeline.push_str(&cluster.html_structure);
        pipeline.push_str("\n\n");
        
        pipeline.push_str("pub fn transform_batch(entities: Vec<RawEntity>) -> Result<Vec<ProcessedEntity>> {\n");
        pipeline.push_str("    let mut processed = Vec::new();\n");
        pipeline.push_str("    \n");
        pipeline.push_str("    for entity in entities {\n");
        
        // Add processing logic based on HTML structure
        if cluster.html_structure.contains("table") {
            pipeline.push_str("        // Parse HTML table structure\n");
            pipeline.push_str("        let table_data = parse_html_table(&entity.html_content)?;\n");
        }
        
        if cluster.html_structure.contains("links") {
            pipeline.push_str("        // Extract and validate links\n");
            pipeline.push_str("        let links = extract_html_links(&entity.html_content)?;\n");
        }
        
        pipeline.push_str("        // Transform to ORM entity\n");
        pipeline.push_str("        let processed_entity = ProcessedEntity {\n");
        pipeline.push_str("            uuid: entity.uuid,\n");
        pipeline.push_str("            processed_content: transform_html_content(entity.html_content)?,\n");
        pipeline.push_str("            // Add more fields based on semantic analysis\n");
        pipeline.push_str("        };\n");
        pipeline.push_str("        \n");
        pipeline.push_str("        processed.push(processed_entity);\n");
        pipeline.push_str("    }\n");
        pipeline.push_str("    \n");
        pipeline.push_str("    Ok(processed)\n");
        pipeline.push_str("}\n");
        
        Ok(pipeline)
    }
    
    /// Prepare cluster content for AI analysis
    fn prepare_cluster_content_for_ai(cluster: &HTMLPatternCluster) -> Result<String> {
        let mut content = String::new();
        
        content.push_str(&format!("CLUSTER ANALYSIS REQUEST\n"));
        content.push_str(&format!("Cluster ID: {}\n", cluster.cluster_id));
        content.push_str(&format!("Entity Count: {}\n", cluster.entity_count));
        content.push_str(&format!("HTML Structure: {}\n", cluster.html_structure));
        content.push_str(&format!("Semantic Tags: {:?}\n\n", cluster.semantic_tags));
        
        content.push_str("EXAMPLE ENTITIES:\n");
        for (i, example) in cluster.example_entities.iter().enumerate() {
            content.push_str(&format!("Example {}:\n{}\n\n", i + 1, example));
        }
        
        Ok(content)
    }
    
    /// Run AI analysis for a cluster to generate enhanced models
    async fn run_ai_analysis_for_cluster(
        ai_engine: &mut super::ai_integration::AIAnalysisEngine,
        cluster: &HTMLPatternCluster,
        cluster_content: &str
    ) -> Result<AIEnhancedAnalysis> {
        // Use the hbf-analyzer agent to generate enhanced models
        let relationships = ai_engine.analyze_html_content(&cluster.cluster_id, cluster_content).await?;
        
        // Generate enhanced ORM model based on AI analysis
        let enhanced_orm_model = Self::generate_ai_enhanced_orm_model(cluster, &relationships)?;
        
        // Generate enhanced transformation pipeline
        let enhanced_pipeline = Self::generate_ai_enhanced_pipeline(cluster, &relationships)?;
        
        Ok(AIEnhancedAnalysis {
            enhanced_orm_model,
            enhanced_transformation_pipeline: enhanced_pipeline,
            discovered_relationships: relationships,
        })
    }
    
    /// Generate AI-enhanced ORM model
    fn generate_ai_enhanced_orm_model(cluster: &HTMLPatternCluster, relationships: &[super::types::DiscoveredRelationship]) -> Result<String> {
        let mut model = String::new();
        
        model.push_str("use sea_orm::entity::prelude::*;\n");
        model.push_str("use serde::{Deserialize, Serialize};\n\n");
        
        // Determine model name based on semantic analysis
        let model_name = if cluster.semantic_tags.contains(&"settlement".to_string()) {
            "SettlementEntity"
        } else if cluster.semantic_tags.contains(&"dungeon".to_string()) {
            "DungeonEntity" 
        } else if cluster.semantic_tags.contains(&"character".to_string()) {
            "CharacterEntity"
        } else if cluster.semantic_tags.contains(&"organization".to_string()) {
            "OrganizationEntity"
        } else if cluster.semantic_tags.contains(&"item".to_string()) {
            "ItemEntity"
        } else {
            "GenericEntity"
        };
        
        model.push_str(&format!("/// {} extracted from HexRoll HBF data\n", model_name));
        model.push_str(&format!("/// Cluster: {} ({} entities)\n", cluster.cluster_id, cluster.entity_count));
        model.push_str("#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]\n");
        model.push_str(&format!("#[sea_orm(table_name = \"{}\")]\n", 
            model_name.to_lowercase().replace("entity", "")));
        model.push_str("pub struct Model {\n");
        model.push_str("    #[sea_orm(primary_key)]\n");
        model.push_str("    pub id: i32,\n");
        model.push_str("    \n");
        model.push_str("    /// Unique identifier from HexRoll\n");
        model.push_str("    #[sea_orm(unique)]\n");
        model.push_str("    pub uuid: String,\n");
        model.push_str("    \n");
        
        // Add model-specific fields based on semantic analysis
        match model_name {
            "SettlementEntity" => {
                model.push_str("    /// Settlement name\n");
                model.push_str("    pub name: String,\n");
                model.push_str("    \n");
                model.push_str("    /// Type of settlement (village, town, city)\n");
                model.push_str("    pub settlement_type: Option<String>,\n");
                model.push_str("    \n");
                model.push_str("    /// Population count\n");
                model.push_str("    pub population: Option<i32>,\n");
                model.push_str("    \n");
                model.push_str("    /// Region or area location\n");
                model.push_str("    pub region: Option<String>,\n");
                model.push_str("    \n");
                model.push_str("    /// Buildings and features (JSON)\n");
                model.push_str("    #[sea_orm(column_type = \"Json\")]\n");
                model.push_str("    pub buildings: Option<serde_json::Value>,\n");
                model.push_str("    \n");
                model.push_str("    /// Rich HTML description\n");
                model.push_str("    #[sea_orm(column_type = \"Text\")]\n");
                model.push_str("    pub description_html: Option<String>,\n");
            }
            "DungeonEntity" => {
                model.push_str("    /// Dungeon name\n");
                model.push_str("    pub name: String,\n");
                model.push_str("    \n");
                model.push_str("    /// Dungeon type (cave, tomb, crypt)\n");
                model.push_str("    pub dungeon_type: Option<String>,\n");
                model.push_str("    \n");
                model.push_str("    /// Difficulty level\n");
                model.push_str("    pub difficulty: Option<i32>,\n");
                model.push_str("    \n");
                model.push_str("    /// Number of levels/floors\n");
                model.push_str("    pub levels: Option<i32>,\n");
                model.push_str("    \n");
                model.push_str("    /// Rooms and areas (JSON)\n");
                model.push_str("    #[sea_orm(column_type = \"Json\")]\n");
                model.push_str("    pub rooms: Option<serde_json::Value>,\n");
                model.push_str("    \n");
                model.push_str("    /// Rich HTML description\n");
                model.push_str("    #[sea_orm(column_type = \"Text\")]\n");
                model.push_str("    pub description_html: Option<String>,\n");
            }
            "OrganizationEntity" => {
                model.push_str("    /// Organization name\n");
                model.push_str("    pub name: String,\n");
                model.push_str("    \n");
                model.push_str("    /// Organization type (faction, guild, cult)\n");
                model.push_str("    pub organization_type: Option<String>,\n");
                model.push_str("    \n");
                model.push_str("    /// Power level or influence\n");
                model.push_str("    pub influence: Option<i32>,\n");
                model.push_str("    \n");
                model.push_str("    /// Members and hierarchy (JSON)\n");
                model.push_str("    #[sea_orm(column_type = \"Json\")]\n");
                model.push_str("    pub members: Option<serde_json::Value>,\n");
                model.push_str("    \n");
                model.push_str("    /// Rich HTML description\n");
                model.push_str("    #[sea_orm(column_type = \"Text\")]\n");
                model.push_str("    pub description_html: Option<String>,\n");
            }
            _ => {
                model.push_str("    /// Entity name\n");
                model.push_str("    pub name: Option<String>,\n");
                model.push_str("    \n");
                model.push_str("    /// Raw HTML content from HexRoll\n");
                model.push_str("    #[sea_orm(column_type = \"Text\")]\n");
                model.push_str("    pub raw_html_content: Option<String>,\n");
            }
        }
        
        model.push_str("    \n");
        model.push_str("    /// Creation timestamp\n");
        model.push_str("    pub created_at: DateTime<chrono::Utc>,\n");
        model.push_str("    \n");
        model.push_str("    /// Last updated timestamp\n");
        model.push_str("    pub updated_at: DateTime<chrono::Utc>,\n");
        model.push_str("}\n\n");
        
        // Add relations based on discovered relationships
        model.push_str("#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\n");
        model.push_str("pub enum Relation {\n");
        
        // Add specific relations based on entity type
        if !relationships.is_empty() {
            model.push_str("    /// References to related entities\n");
            model.push_str("    #[sea_orm(has_many = \"super::entity_refs::Entity\")]\n");
            model.push_str("    EntityRefs,\n");
        }
        
        model.push_str("}\n\n");
        
        // Add ActiveModel behavior
        model.push_str("impl ActiveModelBehavior for ActiveModel {\n");
        model.push_str("    fn new() -> Self {\n");
        model.push_str("        Self {\n");
        model.push_str("            created_at: Set(chrono::Utc::now()),\n");
        model.push_str("            updated_at: Set(chrono::Utc::now()),\n");
        model.push_str("            ..ActiveModelTrait::default()\n");
        model.push_str("        }\n");
        model.push_str("    }\n");
        model.push_str("    \n");
        model.push_str("    fn before_save<C>(self, _db: &C, insert: bool) -> Result<Self, DbErr>\n");
        model.push_str("    where\n");
        model.push_str("        C: ConnectionTrait,\n");
        model.push_str("    {\n");
        model.push_str("        let mut this = self;\n");
        model.push_str("        if !insert {\n");
        model.push_str("            this.updated_at = Set(chrono::Utc::now());\n");
        model.push_str("        }\n");
        model.push_str("        Ok(this)\n");
        model.push_str("    }\n");
        model.push_str("}\n");
        
        Ok(model)
    }
    
    /// Generate AI-enhanced transformation pipeline
    fn generate_ai_enhanced_pipeline(cluster: &HTMLPatternCluster, relationships: &[super::types::DiscoveredRelationship]) -> Result<String> {
        let mut pipeline = String::new();
        
        pipeline.push_str("//! AI-Enhanced transformation pipeline\n");
        pipeline.push_str(&format!("//! Cluster: {} ({} entities)\n", cluster.cluster_id, cluster.entity_count));
        pipeline.push_str(&format!("//! HTML Structure: {}\n", cluster.html_structure));
        pipeline.push_str(&format!("//! Semantic Tags: {:?}\n", cluster.semantic_tags));
        pipeline.push_str(&format!("//! Discovered Relationships: {}\n\n", relationships.len()));
        
        pipeline.push_str("use anyhow::Result;\n");
        pipeline.push_str("use scraper::{Html, Selector};\n");
        pipeline.push_str("use serde_json::Value;\n");
        pipeline.push_str("use super::types::{RawEntity, ProcessedEntity};\n\n");
        
        pipeline.push_str("/// Transform a batch of entities from this cluster\n");
        pipeline.push_str("pub async fn transform_batch(entities: Vec<RawEntity>) -> Result<Vec<ProcessedEntity>> {\n");
        pipeline.push_str("    let mut processed = Vec::new();\n");
        pipeline.push_str("    \n");
        pipeline.push_str("    for entity in entities {\n");
        pipeline.push_str("        match transform_single_entity(&entity).await {\n");
        pipeline.push_str("            Ok(processed_entity) => processed.push(processed_entity),\n");
        pipeline.push_str("            Err(e) => {\n");
        pipeline.push_str("                eprintln!(\"Failed to transform entity {}: {}\", entity.uuid, e);\n");
        pipeline.push_str("                // Continue processing other entities\n");
        pipeline.push_str("            }\n");
        pipeline.push_str("        }\n");
        pipeline.push_str("    }\n");
        pipeline.push_str("    \n");
        pipeline.push_str("    Ok(processed)\n");
        pipeline.push_str("}\n\n");
        
        pipeline.push_str("/// Transform a single entity with AI-enhanced processing\n");
        pipeline.push_str("async fn transform_single_entity(entity: &RawEntity) -> Result<ProcessedEntity> {\n");
        pipeline.push_str("    let html_doc = Html::parse_document(&entity.html_content);\n");
        pipeline.push_str("    \n");
        
        // Add processing logic based on semantic tags
        if cluster.semantic_tags.contains(&"settlement".to_string()) {
            pipeline.push_str("    // Settlement-specific parsing\n");
            pipeline.push_str("    let name = extract_settlement_name(&html_doc)?;\n");
            pipeline.push_str("    let settlement_type = extract_settlement_type(&html_doc)?;\n");
            pipeline.push_str("    let buildings = extract_settlement_buildings(&html_doc)?;\n");
            pipeline.push_str("    \n");
        } else if cluster.semantic_tags.contains(&"dungeon".to_string()) {
            pipeline.push_str("    // Dungeon-specific parsing\n");
            pipeline.push_str("    let name = extract_dungeon_name(&html_doc)?;\n");
            pipeline.push_str("    let dungeon_type = extract_dungeon_type(&html_doc)?;\n");
            pipeline.push_str("    let rooms = extract_dungeon_rooms(&html_doc)?;\n");
            pipeline.push_str("    \n");
        } else if cluster.semantic_tags.contains(&"organization".to_string()) {
            pipeline.push_str("    // Organization-specific parsing\n");
            pipeline.push_str("    let name = extract_organization_name(&html_doc)?;\n");
            pipeline.push_str("    let org_type = extract_organization_type(&html_doc)?;\n");
            pipeline.push_str("    let members = extract_organization_members(&html_doc)?;\n");
            pipeline.push_str("    \n");
        } else {
            pipeline.push_str("    // Generic entity parsing\n");
            pipeline.push_str("    let name = extract_entity_name(&html_doc).ok();\n");
            pipeline.push_str("    \n");
        }
        
        // Add relationship extraction
        if !relationships.is_empty() {
            pipeline.push_str("    // Extract relationships discovered by AI\n");
            pipeline.push_str("    let extracted_links = extract_entity_links(&html_doc)?;\n");
            pipeline.push_str("    let validated_relationships = validate_relationships(&extracted_links)?;\n");
            pipeline.push_str("    \n");
        }
        
        pipeline.push_str("    Ok(ProcessedEntity {\n");
        pipeline.push_str("        uuid: entity.uuid.clone(),\n");
        pipeline.push_str("        name,\n");
        pipeline.push_str("        processed_content: clean_html_content(&entity.html_content)?,\n");
        pipeline.push_str("        extracted_data: extract_structured_data(&html_doc)?,\n");
        pipeline.push_str("        relationships: validated_relationships.unwrap_or_default(),\n");
        pipeline.push_str("        raw_html: Some(entity.html_content.clone()),\n");
        pipeline.push_str("    })\n");
        pipeline.push_str("}\n\n");
        
        // Add helper functions
        pipeline.push_str("/// Extract structured data from HTML based on cluster patterns\n");
        pipeline.push_str("fn extract_structured_data(html_doc: &Html) -> Result<Value> {\n");
        pipeline.push_str("    let mut data = serde_json::Map::new();\n");
        pipeline.push_str("    \n");
        
        if cluster.html_structure.contains("table") {
            pipeline.push_str("    // Extract table data\n");
            pipeline.push_str("    if let Some(table_data) = extract_table_data(html_doc)? {\n");
            pipeline.push_str("        data.insert(\"table_data\".to_string(), table_data);\n");
            pipeline.push_str("    }\n");
        }
        
        if cluster.html_structure.contains("links") {
            pipeline.push_str("    // Extract link information\n");
            pipeline.push_str("    let links = extract_all_links(html_doc)?;\n");
            pipeline.push_str("    if !links.is_empty() {\n");
            pipeline.push_str("        data.insert(\"links\".to_string(), Value::Array(links));\n");
            pipeline.push_str("    }\n");
        }
        
        pipeline.push_str("    \n");
        pipeline.push_str("    Ok(Value::Object(data))\n");
        pipeline.push_str("}\n");
        
        Ok(pipeline)
    }
    
    /// Determine AI-enhanced strategy type
    fn determine_ai_enhanced_strategy_type(cluster: &HTMLPatternCluster, _ai_analysis: &AIEnhancedAnalysis) -> BatchStrategyType {
        // Enhanced strategy determination based on AI analysis
        if cluster.semantic_tags.contains(&"settlement".to_string()) {
            BatchStrategyType::SettlementProcessing
        } else if cluster.semantic_tags.contains(&"dungeon".to_string()) {
            BatchStrategyType::StructuredTableParsing
        } else if cluster.semantic_tags.contains(&"character".to_string()) {
            BatchStrategyType::CharacterProcessing
        } else if cluster.semantic_tags.contains(&"organization".to_string()) {
            BatchStrategyType::LinkRelationshipMapping
        } else if cluster.html_structure.contains("links") {
            BatchStrategyType::LinkRelationshipMapping
        } else if cluster.html_structure.contains("table") {
            BatchStrategyType::StructuredTableParsing
        } else {
            BatchStrategyType::GenericTextProcessing
        }
    }
    
    /// Calculate optimal batch size for processing
    fn calculate_optimal_batch_size(entity_count: usize) -> usize {
        match entity_count {
            0..=100 => 10,
            101..=1000 => 50,
            1001..=10000 => 100,
            _ => 200,
        }
    }
    
    /// Estimate processing time for cluster
    fn estimate_processing_time(entity_count: usize) -> u64 {
        // Estimate seconds based on entity count and complexity
        (entity_count as f64 * 0.01).ceil() as u64
    }
}

/// Batch processing strategy for a pattern cluster
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BatchProcessingStrategy {
    pub cluster_id: String,
    pub strategy_type: BatchStrategyType,
    pub entity_count: usize,
    pub orm_model: String,
    pub transformation_pipeline: String,
    pub batch_size: usize,
    pub estimated_processing_time: u64,
    pub semantic_tags: Vec<String>,
}

/// Types of batch processing strategies
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum BatchStrategyType {
    StructuredTableParsing,
    ListItemExtraction,
    LinkRelationshipMapping,
    SettlementProcessing,
    CharacterProcessing,
    GenericTextProcessing,
}

impl BatchProcessingStrategy {
    /// Generate comprehensive processing plan for all 70k entities
    pub fn generate_complete_processing_plan(strategies: &[BatchProcessingStrategy]) -> String {
        let mut plan = String::new();
        
        plan.push_str("# Complete HBF Processing Plan for 70k+ Entities\n\n");
        
        let total_entities: usize = strategies.iter().map(|s| s.entity_count).sum();
        let total_time: u64 = strategies.iter().map(|s| s.estimated_processing_time).sum();
        
        plan.push_str(&format!("Total entities to process: {}\n", total_entities));
        plan.push_str(&format!("Estimated total processing time: {} seconds\n", total_time));
        plan.push_str(&format!("Number of processing strategies: {}\n\n", strategies.len()));
        
        for (i, strategy) in strategies.iter().enumerate() {
            plan.push_str(&format!("## Strategy {}: {} ({} entities)\n", 
                                  i + 1, strategy.cluster_id, strategy.entity_count));
            plan.push_str(&format!("Type: {:?}\n", strategy.strategy_type));
            plan.push_str(&format!("Batch size: {}\n", strategy.batch_size));
            plan.push_str(&format!("Estimated time: {} seconds\n", strategy.estimated_processing_time));
            plan.push_str(&format!("Semantic tags: {:?}\n\n", strategy.semantic_tags));
        }
        
        plan
    }
}
