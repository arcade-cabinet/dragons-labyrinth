//! Template processing for code generation.
//!
//! This module provides template-based code generation functionality
//! for processing analysis results into game resources.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use anyhow::Result;

// Local type definitions to replace dl_types imports
use crate::orchestration::EntityCategory;

/// Basic inventory structure for template processing
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Inventory {
    pub entities: Vec<EntityModel>,
    pub metadata: HashMap<String, String>,
}

/// Entity model for template processing
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EntityModel {
    pub name: String,
    pub description: Option<String>,
    pub fields: Vec<FieldModel>,
    pub relationships: Vec<String>,
    pub spatial_data: Option<String>,
}

/// Field model for template processing
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FieldModel {
    pub name: String,
    pub field_type: String,
    pub description: Option<String>,
    pub required: bool,
    pub connections: Vec<String>,
}

/// Template manager for code generation
#[derive(Debug, Clone)]
pub struct TemplateManager {
    /// Available templates by category
    templates: HashMap<String, String>,
    /// Tera template engine
    tera: tera::Tera,
}

impl TemplateManager {
    pub fn new() -> Result<Self> {
        let mut templates = HashMap::new();
        
        // Add basic templates
        templates.insert("regions".to_string(), "regions_analysis.j2".to_string());
        templates.insert("settlements".to_string(), "settlements_analysis.j2".to_string());
        templates.insert("factions".to_string(), "factions_analysis.j2".to_string());
        templates.insert("dungeons".to_string(), "dungeons_analysis.j2".to_string());
        
        // Initialize Tera template engine
        let mut tera = tera::Tera::default();
        
        // Add basic ECS component template
        tera.add_raw_template("ecs_component", ECS_COMPONENT_TEMPLATE)?;
        tera.add_raw_template("module_header", MODULE_HEADER_TEMPLATE)?;
        
        Ok(Self { templates, tera })
    }

    pub fn render_entity_template(
        &self,
        category: &EntityCategory,
        inventory: &Inventory,
        metadata: Option<&HashMap<String, String>>,
    ) -> Result<String> {
        // Create context for template rendering
        let mut context = tera::Context::new();
        context.insert("category", &category.as_str());
        context.insert("inventory", inventory);
        context.insert("entities", &inventory.entities);
        
        if let Some(meta) = metadata {
            context.insert("metadata", meta);
        }

        // Try to use custom template first, fallback to basic generation
        if let Some(template_name) = self.templates.get(&category.as_str().to_lowercase()) {
            // Use Tera template if available
            if self.tera.get_template_names().any(|name| name == template_name) {
                return self.tera.render(template_name, &context)
                    .map_err(|e| anyhow::anyhow!("Template rendering error: {}", e));
            }
        }

        // Fallback to basic generation
        self.generate_basic_module(category, inventory, metadata)
    }

    pub fn render_ecs_components(
        &self,
        category: &EntityCategory,
        inventory: &Inventory,
    ) -> Result<String> {
        let mut context = tera::Context::new();
        context.insert("category", &category.as_str());
        context.insert("inventory", inventory);
        context.insert("entities", &inventory.entities);
        
        self.tera.render("ecs_component", &context)
            .map_err(|e| anyhow::anyhow!("ECS component template error: {}", e))
    }

    fn generate_basic_module(
        &self,
        category: &EntityCategory,
        inventory: &Inventory,
        _metadata: Option<&HashMap<String, String>>,
    ) -> Result<String> {
        let mut lines = vec![
            format!("//! Generated models for {} entities", category.as_str()),
            "//! This file was generated by the analysis system. Do not edit manually.".to_string(),
            "".to_string(),
            "use serde::{Deserialize, Serialize};".to_string(),
            "use std::collections::HashMap;".to_string(),
            "use dl_types::core::{HexCoord, BiomeType};".to_string(),
            "".to_string(),
        ];

        // Generate structs for each entity
        for entity in &inventory.entities {
            lines.push(format!("/// {}", entity.description.as_ref().unwrap_or(&"Generated entity".to_string())));
            lines.push("#[derive(Debug, Clone, Serialize, Deserialize)]".to_string());
            lines.push(format!("pub struct {} {{", entity.name));

            for field in &entity.fields {
                if let Some(desc) = &field.description {
                    lines.push(format!("    /// {}", desc));
                }
                lines.push(format!("    pub {}: {},", field.name, field.field_type));
            }

            lines.push("}".to_string());
            lines.push("".to_string());
            
            // Add implementation block
            lines.push(format!("impl {} {{", entity.name));
            lines.push("    pub fn new() -> Self {".to_string());
            lines.push("        Self::default()".to_string());
            lines.push("    }".to_string());
            lines.push("}".to_string());
            lines.push("".to_string());
        }

        Ok(lines.join("\n"))
    }

    /// Generate complete runtime analysis engine templates
    pub fn generate_runtime_analysis_template(&self) -> Result<String> {
        let mut context = tera::Context::new();
        context.insert("timestamp", &chrono::Utc::now().to_rfc3339());
        
        self.tera.render("runtime_analysis", &context)
            .or_else(|_| Ok(RUNTIME_ANALYSIS_TEMPLATE.to_string()))
    }
}

/// Basic ECS component template
const ECS_COMPONENT_TEMPLATE: &str = r#"//! Generated ECS components for {{ category }} entities
//! Generated at {{ timestamp | default(value="unknown time") }}

use bevy::prelude::*;
use serde::{Deserialize, Serialize};
use dl_types::core::{HexCoord, BiomeType};

{% for entity in entities %}
/// {{ entity.description | default(value="Generated entity component") }}
#[derive(Component, Debug, Clone, Serialize, Deserialize)]
pub struct {{ entity.name }} {
    {% for field in entity.fields -%}
    /// {{ field.description | default(value="Entity field") }}
    pub {{ field.name }}: {{ field.field_type }},
    {% endfor %}
}

impl Default for {{ entity.name }} {
    fn default() -> Self {
        Self {
            {% for field in entity.fields -%}
            {{ field.name }}: Default::default(),
            {% endfor %}
        }
    }
}

{% endfor %}
"#;

/// Module header template
const MODULE_HEADER_TEMPLATE: &str = r#"//! Generated module for {{ category }}
//! 
//! This module contains auto-generated types and functionality
//! for Dragon's Labyrinth {{ category }} entities.
//! 
//! Generated at: {{ timestamp | default(value="unknown time") }}

use serde::{Deserialize, Serialize};
use bevy::prelude::*;
use std::collections::HashMap;

"#;

/// Runtime analysis engine template
const RUNTIME_ANALYSIS_TEMPLATE: &str = r#"//! Runtime seed analysis engine for organized JSON pools
//! 
//! This module provides AI-driven analysis of categorized data pools
//! for dynamic seed generation during gameplay.

use anyhow::Result;
use openai_dive::v1::api::Client;
use serde_json::Value;
use std::collections::HashMap;
use std::path::Path;

/// Runtime AI analysis engine for seed generation
pub struct SeedAnalysisEngine {
    ai_client: Client,
    categorized_pools: CategorizedDataPools,
    analysis_cache: HashMap<String, AnalysisResult>,
}

impl SeedAnalysisEngine {
    pub fn new(pools_dir: &Path) -> Result<Self> {
        let ai_client = Client::new(std::env::var("OPENAI_API_KEY")?);
        let categorized_pools = CategorizedDataPools::load_from_dir(pools_dir)?;
        
        Ok(Self {
            ai_client,
            categorized_pools,
            analysis_cache: HashMap::new(),
        })
    }

    pub async fn analyze_pools(&mut self, category: &str) -> Result<AnalysisResult> {
        if let Some(cached) = self.analysis_cache.get(category) {
            return Ok(cached.clone());
        }

        let pool_data = self.categorized_pools.get_category_data(category)?;
        let analysis = self.run_ai_analysis(category, &pool_data).await?;
        
        self.analysis_cache.insert(category.to_string(), analysis.clone());
        Ok(analysis)
    }

    pub async fn generate_game_seeds(&mut self, category: &str, count: usize) -> Result<Vec<GameSeed>> {
        let analysis = self.analyze_pools(category).await?;
        let seeds = self.synthesize_seeds(&analysis, count).await?;
        Ok(seeds)
    }

    async fn run_ai_analysis(&self, category: &str, data: &Value) -> Result<AnalysisResult> {
        // AI analysis implementation here
        todo!("Implement AI analysis of organized pools")
    }

    async fn synthesize_seeds(&self, analysis: &AnalysisResult, count: usize) -> Result<Vec<GameSeed>> {
        // Seed synthesis implementation here
        todo!("Implement game seed synthesis")
    }
}

/// Organized data pools by category
#[derive(Debug, Clone)]
pub struct CategorizedDataPools {
    pub regions: Vec<Value>,
    pub settlements: Vec<Value>,
    pub dungeons: Vec<Value>,
    pub factions: Vec<Value>,
    pub books: Vec<Value>,
}

impl CategorizedDataPools {
    pub fn load_from_dir(dir: &Path) -> Result<Self> {
        todo!("Implement loading organized pools from directory")
    }

    pub fn get_category_data(&self, category: &str) -> Result<&Vec<Value>> {
        match category {
            "regions" => Ok(&self.regions),
            "settlements" => Ok(&self.settlements),
            "dungeons" => Ok(&self.dungeons),
            "factions" => Ok(&self.factions),
            "books" => Ok(&self.books),
            _ => Err(anyhow::anyhow!("Unknown category: {}", category)),
        }
    }
}

/// Result of AI analysis
#[derive(Debug, Clone)]
pub struct AnalysisResult {
    pub category: String,
    pub patterns: Vec<String>,
    pub themes: Vec<String>,
    pub seed_potential: f32,
}

/// Generated game seed
#[derive(Debug, Clone)]
pub struct GameSeed {
    pub id: String,
    pub category: String,
    pub data: Value,
    pub confidence: f32,
}
"#;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_template_manager_creation() {
        let manager = TemplateManager::new();
        assert!(manager.is_ok());
    }

    #[test]
    fn test_basic_module_generation() {
        let manager = TemplateManager::new().unwrap();
        let category = EntityCategory::Regions;
        
        let inventory = Inventory {
            entities: vec![EntityModel {
                name: "TestEntity".to_string(),
                description: Some("A test entity".to_string()),
                fields: vec![FieldModel {
                    name: "test_field".to_string(),
                    field_type: "String".to_string(),
                    description: Some("A test field".to_string()),
                    required: true,
                    connections: vec![],
                }],
                relationships: vec![],
                spatial_data: None,
            }],
            metadata: HashMap::new(),
        };
        
        let result = manager.generate_basic_module(&category, &inventory, None);
        assert!(result.is_ok());
        let code = result.unwrap();
        assert!(code.contains("TestEntity"));
        assert!(code.contains("test_field: String"));
    }
}
