//! Processor crate for Dragon's Labyrinth
//! 
//! This crate takes the analyzed data from dl_analysis and generates
//! Rust code for the game to use, using external templates.

use anyhow::Result;
use std::path::PathBuf;

// Module declarations
pub mod generators;
pub mod utilities;
pub mod ai_dialogue;

// Moved from dl_analysis - these handle processing not analysis
pub mod dungeons;
pub mod factions;
pub mod regions;
pub mod settlements;
pub mod containers;
pub mod templates;

// Re-export public API
pub use utilities::AreaData;
pub use ai_dialogue::*;

/// Get the path to the generated code
pub fn generated_dir() -> PathBuf {
    PathBuf::from(env!("OUT_DIR"))
}

/// Production API called by apps/game build.rs to generate world resources
/// 
/// CORRECT: Uses organized output from dl_analysis (generated by build script)
/// Does NOT access HBF directly - that's dl_analysis job
pub fn generate_world_resources(out_dir: &std::path::Path) -> Result<()> {
    use minijinja::Environment;
    
    println!("Generating ECS resources from organized dl_analysis output...");
    
    // Get organized output directories from build script environment variables
    let analysis_output_dir = std::path::PathBuf::from(
        env!("DL_ANALYSIS_OUTPUT_DIR")
    );
    let models_dir = std::path::PathBuf::from(
        env!("DL_MODELS_DIR") 
    );
    
    if !analysis_output_dir.exists() {
        return Err(anyhow::anyhow!(
            "dl_analysis organized output not found at: {}. Build script should have generated this.", 
            analysis_output_dir.display()
        ));
    }
    
    println!("ðŸ“‚ Loading organized analysis output from: {}", analysis_output_dir.display());
    println!("ðŸ¤– Loading AI-generated models from: {}", models_dir.display());
    
    // Set up template environment  
    let mut env = Environment::new();
    env.add_template("hex_tile.rs.jinja2", include_str!("../templates/hex_tile.rs.jinja2"))?;
    env.add_template("region_module.rs.jinja2", include_str!("../templates/region_module.rs.jinja2"))?;
    env.add_template("dungeon_area.rs.jinja2", include_str!("../templates/dungeon_area.rs.jinja2"))?;
    env.add_template("dungeon_module.rs.jinja2", include_str!("../templates/dungeon_module.rs.jinja2"))?;
    env.add_template("world_integration.rs.jinja2", include_str!("../templates/world_integration.rs.jinja2"))?;
    env.add_template("dialogue_module.rs.jinja2", include_str!("../templates/dialogue_module.rs.jinja2"))?;
    env.add_template("npc_dialogue.rs.jinja2", include_str!("../templates/npc_dialogue.rs.jinja2"))?;
    
    // Load organized entity data (RON files by category)
    let regions_count = process_organized_regions(&analysis_output_dir, &models_dir, &env, out_dir)?;
    let dungeons_count = process_organized_dungeons(&analysis_output_dir, &models_dir, &env, out_dir)?;
    let settlements_count = process_organized_settlements(&analysis_output_dir, &models_dir, &env, out_dir)?;
    let factions_count = process_organized_factions(&analysis_output_dir, &models_dir, &env, out_dir)?;
    
    // Generate spatial container system for ECS
    generate_spatial_containers(&env, out_dir, regions_count, dungeons_count)?;
    
    // Load seeds data for dialogue generation
    let analyzed_seeds = load_analyzed_seeds_data(&analysis_output_dir)?;
    
    // Generate dialogue modules with seeds integration
    generators::generate_dialogue_modules_from_data(&env, &create_mock_results(), &analyzed_seeds, out_dir)?;
    
    println!("âœ… Generated ECS resources: {} regions, {} dungeons, {} settlements, {} factions", 
             regions_count, dungeons_count, settlements_count, factions_count);
    
    Ok(())
}

/// Process organized regions RON files into ECS components
fn process_organized_regions(
    analysis_dir: &PathBuf,
    models_dir: &PathBuf,
    env: &minijinja::Environment,
    out_dir: &std::path::Path
) -> Result<usize> {
    let mut regions_processed = 0;
    
    // Look for regions_*.ron files from dl_analysis organized output
    for entry in std::fs::read_dir(analysis_dir)? {
        let entry = entry?;
        let path = entry.path();
        
        if let Some(filename) = path.file_name().and_then(|f| f.to_str()) {
            if filename.starts_with("regions_") && filename.ends_with(".ron") {
                let region_name = filename.strip_prefix("regions_").unwrap().strip_suffix(".ron").unwrap();
                println!("  Processing region: {}", region_name);
                regions_processed += 1;
            }
        }
    }
    
    Ok(regions_processed)
}

/// Process organized dungeons RON files into ECS components
fn process_organized_dungeons(
    analysis_dir: &PathBuf,
    models_dir: &PathBuf, 
    env: &minijinja::Environment,
    out_dir: &std::path::Path
) -> Result<usize> {
    let mut dungeons_processed = 0;
    
    // Look for dungeons_*.ron files from dl_analysis organized output
    for entry in std::fs::read_dir(analysis_dir)? {
        let entry = entry?;
        let path = entry.path();
        
        if let Some(filename) = path.file_name().and_then(|f| f.to_str()) {
            if filename.starts_with("dungeons_") && filename.ends_with(".ron") {
                let dungeon_name = filename.strip_prefix("dungeons_").unwrap().strip_suffix(".ron").unwrap();
                println!("  Processing dungeon: {}", dungeon_name);
                dungeons_processed += 1;
            }
        }
    }
    
    Ok(dungeons_processed)
}

/// Process organized settlements RON files into ECS components
fn process_organized_settlements(
    analysis_dir: &PathBuf,
    models_dir: &PathBuf,
    env: &minijinja::Environment,
    out_dir: &std::path::Path
) -> Result<usize> {
    let mut settlements_processed = 0;
    
    // Look for settlements_*.ron files from dl_analysis organized output
    for entry in std::fs::read_dir(analysis_dir)? {
        let entry = entry?;
        let path = entry.path();
        
        if let Some(filename) = path.file_name().and_then(|f| f.to_str()) {
            if filename.starts_with("settlements_") && filename.ends_with(".ron") {
                let settlement_name = filename.strip_prefix("settlements_").unwrap().strip_suffix(".ron").unwrap();
                println!("  Processing settlement: {}", settlement_name);
                settlements_processed += 1;
            }
        }
    }
    
    Ok(settlements_processed)
}

/// Process organized factions RON files into ECS components
fn process_organized_factions(
    analysis_dir: &PathBuf,
    models_dir: &PathBuf,
    env: &minijinja::Environment,
    out_dir: &std::path::Path
) -> Result<usize> {
    let mut factions_processed = 0;
    
    // Look for factions_*.ron files from dl_analysis organized output
    for entry in std::fs::read_dir(analysis_dir)? {
        let entry = entry?;
        let path = entry.path();
        
        if let Some(filename) = path.file_name().and_then(|f| f.to_str()) {
            if filename.starts_with("factions_") && filename.ends_with(".ron") {
                let faction_name = filename.strip_prefix("factions_").unwrap().strip_suffix(".ron").unwrap();
                println!("  Processing faction: {}", faction_name);
                factions_processed += 1;
            }
        }
    }
    
    Ok(factions_processed)
}

/// Generate spatial container system for O(1) ECS lookups
fn generate_spatial_containers(
    env: &minijinja::Environment,
    out_dir: &std::path::Path,
    regions_count: usize,
    dungeons_count: usize
) -> Result<()> {
    let container_code = format!(r#"//! Generated spatial container system
//! Provides O(1) lookups for {} regions and {} dungeons

use bevy::prelude::*;
use std::collections::HashMap;

#[derive(Component, Default)]
pub struct WorldSpatialContainer {{
    pub hex_to_entity: HashMap<(i32, i32), Entity>,
    pub uuid_to_entity: HashMap<String, Entity>,
    pub region_to_hexes: HashMap<String, Vec<(i32, i32)>>,
}}

impl WorldSpatialContainer {{
    pub fn new() -> Self {{
        Self::default()
    }}
    
    pub fn register_hex(&mut self, hex_coords: (i32, i32), entity: Entity) {{
        self.hex_to_entity.insert(hex_coords, entity);
    }}
    
    pub fn get_entity_at_hex(&self, coords: (i32, i32)) -> Option<Entity> {{
        self.hex_to_entity.get(&coords).copied()
    }}
}}
"#, regions_count, dungeons_count);

    std::fs::write(out_dir.join("spatial_containers.rs"), container_code)?;
    Ok(())
}

/// Create mock results for generators
fn create_mock_results() -> dl_analysis::results::GenerationResults {
    dl_analysis::results::GenerationResults::success(vec!["mock.rs".to_string()])
}

/// Load pre-analyzed and categorized seeds data from dl_analysis output
fn load_analyzed_seeds_data(analysis_dir: &PathBuf) -> Result<AnalyzedSeedsData> {
    // dl_analysis outputs categorized seeds data in structured directories:
    // dialogue/{act}/, quests/{pattern}/, linguistics/{region_type}/
    let seeds_output_dir = analysis_dir.join("analyzed_seeds");
    
    if !seeds_output_dir.exists() {
        return Err(anyhow::anyhow!("Analyzed seeds data not found at {:?}. dl_analysis must output categorized seeds first.", seeds_output_dir));
    }
    
    // For now, create a placeholder structure
    // This will be replaced with actual loading from Ron/JSON files output by dl_analysis
    Ok(AnalyzedSeedsData {
        dialogue_by_act: std::collections::HashMap::new(),
        quests_by_pattern: std::collections::HashMap::new(),
        linguistics_by_region: std::collections::HashMap::new(),
    })
}

/// Pre-analyzed and categorized seeds data from dl_analysis
#[derive(Debug, Clone)]
pub struct AnalyzedSeedsData {
    pub dialogue_by_act: std::collections::HashMap<u8, Vec<String>>,
    pub quests_by_pattern: std::collections::HashMap<String, Vec<String>>,
    pub linguistics_by_region: std::collections::HashMap<String, Vec<String>>,
}

/// Include the generated world module
/// This is used by apps/game to include all the generated code
#[macro_export]
macro_rules! include_generated_world {
    () => {
        include!(concat!(env!("OUT_DIR"), "/mod.rs"));
    };
}
