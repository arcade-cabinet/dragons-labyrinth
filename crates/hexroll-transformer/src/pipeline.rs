use std::collections::HashMap;
use anyhow::Result;
use rusqlite::{Connection, Row};
use sea_orm::{Database, Schema, ConnectionTrait, Set, ActiveModelTrait};
use serde_json::json;

use crate::extractor::*;
use crate::models::*;
use crate::analyzer::OpenAiDiveAnalyzer;
use crate::orm as entities;

pub struct HexrollTransformer {
    conn: Connection,
    ai: OpenAiDiveAnalyzer,
}

impl HexrollTransformer {
    pub fn open(hbf_path: &str, ai_model: &str) -> Result<Self> {
        let conn = Connection::open(hbf_path)?;
        Ok(Self { conn, ai: OpenAiDiveAnalyzer::new(ai_model, 3500) })
    }

    pub fn transform(&self) -> Vec<PageResult> {
        let mut out = Vec::new();
        let mut stmt = self.conn.prepare("SELECT uuid, value FROM Entities WHERE value != ''") .unwrap();
        let mut rows = stmt.query([]).unwrap();
        while let Some(row) = rows.next().unwrap() {
            let uuid: String = row.get(0).unwrap();
            let val: String  = row.get(1).unwrap();
            let trimmed = val.trim();
            let is_json = trimmed.starts_with('{');
            let page_type = if !is_json { detect_page_type(trimmed) } else { PageType::Unknown };
            let mut page = PageResult {
                uuid: uuid.clone(),
                page_type: page_type.clone(),
                title: if !is_json { extract_doc_title(trimmed) } else { None },
                html: if !is_json { Some(trimmed.to_string()) } else { None },
                json: if is_json { serde_json::from_str(trimmed).ok() } else { None },
                hex: None, settlement: None, npc: None, rumor: None, weather: None,
                region: None, biome: None, dungeon_kind: None, dwelling_kind: None, faction_kind: None,
            };
            if matches!(page_type, PageType::Hex) {
                page.hex = extract_hex_info(trimmed);
            }
            if matches!(page_type, PageType::RumorTable) {
                page.rumor = parse_rumor_table(trimmed);
            }
            if let Some(w) = parse_weather_table(trimmed) {
                page.weather = Some(w);
            }
            out.push(page);
        }
        out
    }

    /// Create or overwrite a world database at `db_path` using SeaORM.
    pub fn export_to_sea_db(&self, db_path: &str, pages: &[PageResult]) -> Result<()> {
        let rt = tokio::runtime::Runtime::new()?;
        rt.block_on(async {
            let db = Database::connect(format!("sqlite:{}", db_path)).await?;

            // Recreate schema (drop if exists)
            let schema = Schema::new(db.get_database_backend());
            let drop_order = vec![
                "dialogue","npc_faction","monster","npc","faction","shop",
                "dungeon","dwelling","inn","weather","rumor",
                "settlement","hex","biome","region","realm"]
            ;
            for t in drop_order {
                let _ = db.execute(schema.drop_table_from_entity_dynamic(t)).await;
            }

            // Create tables
            let creates = vec![
                entities::realm::Entity,
                entities::region::Entity,
                entities::biome::Entity,
                entities::hex::Entity,
                entities::settlement::Entity,
                entities::rumor::Entity,
                entities::weather::Entity,
                entities::inn::Entity,
                entities::dwelling::Entity,
                entities::dungeon::Entity,
                entities::monster::Entity,
                entities::faction::Entity,
                entities::npc::Entity,
                entities::npc_faction::Entity,
                entities::shop::Entity,
                entities::dialogue::Entity,
            ];
            for ent in creates {
                db.execute(schema.create_table_from_entity(ent)).await?;
            }

            // Insert a realm placeholder
            entities::realm::ActiveModel {
                id: Set("realm0".to_string()),
                name: Set("Default Realm".to_string()),
                description: Set(Some("Autogenerated".to_string())),
            }.insert(&db).await?;

            // Region & Biome maps
            let mut region_map: HashMap<String,String> = HashMap::new(); // name -> id
            let mut biome_map: HashMap<(String,String),String> = HashMap::new(); // (region, biome) -> id

            // Insert hexes, weather, rumors; derive regions/biomes as we go
            for p in pages {
                if let Some(hex) = &p.hex {
                    let region_name = p.region.clone().unwrap_or_else(|| "Unknown Region".into());
                    let region_id = region_map.entry(region_name.clone()).or_insert_with(|| {
                        let id = format!("region_{}", region_name.replace(" ", "_"));
                        tokio::task::block_in_place(|| id)
                    }).clone();
                    // ensure region exists
                    if let std::collections::hash_map::Entry::Vacant(_) = region_map.entry(region_name.clone()) {
                        // already ensured
                    }
                    // create region row if absent
                    // (we'll try insert and ignore on conflict by catching error)
                    let _ = entities::region::ActiveModel {
                        id: Set(region_id.clone()),
                        name: Set(region_name.clone()),
                        description: Set(None),
                        hex_count: Set(None),
                        biome_counts_json: Set(None),
                    }.insert(&db).await;

                    // biome
                    let biome_name = hex.biome.clone().unwrap_or_else(|| "Unknown".into());
                    let key = (region_name.clone(), biome_name.clone());
                    let biome_id = if let Some(id) = biome_map.get(&key) {
                        id.clone()
                    } else {
                        let id = format!("biome_{}_{}", region_name.replace(" ", "_"), biome_name.replace(" ", "_"));
                        let _ = entities::biome::ActiveModel {
                            id: Set(id.clone()), region_id: Set(region_id.clone()),
                            name: Set(biome_name.clone()), description: Set(None)
                        }.insert(&db).await;
                        biome_map.insert(key, id.clone());
                        id
                    };

                    let model = entities::hex::ActiveModel {
                        id: Set(p.uuid.clone()),
                        realm_id: Set("realm0".into()),
                        region_id: Set(Some(region_id.clone())),
                        biome_id: Set(Some(biome_id.clone())),
                        coord: Set(hex.coord.clone()),
                        description: Set(hex.description.clone()),
                    };
                    let _ = model.insert(&db).await;
                }

                if let Some(w) = &p.weather {
                    if let Some(h) = &p.hex {
                        let _ = entities::weather::ActiveModel {
                            id: Set(0), // auto
                            hex_id: Set(p.uuid.clone()),
                            table_json: Set(serde_json::to_string(&w.rows).unwrap_or("[]".into())),
                            flood_one_in_6_weekly: Set(w.flood_one_in_6_weekly),
                        }.insert(&db).await;
                    }
                }

                if let Some(r) = &p.rumor {
                    // Attach rumor to hex if present; settlement linking can be added later.
                    if p.hex.is_some() {
                        for line in &r.entries {
                            let _ = entities::rumor::ActiveModel {
                                id: Set(0),
                                hex_id: Set(Some(p.uuid.clone())),
                                settlement_id: Set(None),
                                text: Set(line.clone()),
                            }.insert(&db).await;
                        }
                    }
                }
            }

            // NPCs, settlements, factions would be inserted similarly; for brevity, we leave detailed parsing to extractor extensions.

            Ok::<(), anyhow::Error>(())
        })?;
        Ok(())
    }
}
