// AI asset loading and management
// This is REAL runtime code, not generated!

use bevy::prelude::*;
use std::collections::HashMap;
use serde_json::Value;
use std::fs;
use std::path::PathBuf;

/// Resource containing ALL AI-generated assets from build-time
#[derive(Resource)]
pub struct AIGeneratedAssets {
    // Maps: hex worlds generated by MapsAgent
    pub hex_worlds: HashMap<u8, Value>,  // dread_level -> world_data
    
    // Levels: encounters and items generated by LevelsAgent
    pub encounters: Vec<Value>,
    pub sentimental_items: Vec<Value>,
    
    // UI: interface configurations generated by UIAgent
    pub ui_configs: HashMap<u8, Value>, // dread_level -> ui_config
    
    // Dialogue: conversation trees generated by DialogueAgent
    pub dialogue_trees: HashMap<String, Value>, // character -> dialogue_data
    
    // Audio: sound configurations generated by AudioAgent
    pub audio_configs: HashMap<u8, Value>, // dread_level -> audio_config
    
    // Decay: corruption rules generated by DecayAgent
    pub decay_rules: HashMap<u8, Value>, // dread_level -> decay_rules
    
    // Mounts: companion data generated by MountAgent
    pub mount_personalities: HashMap<String, Value>, // mount_type -> personality
    pub bonding_mechanics: Value,
}

impl AIGeneratedAssets {
    /// Load ALL AI-generated assets from build output or assets folder
    pub fn load() -> Self {
        let mut assets = Self {
            hex_worlds: HashMap::new(),
            encounters: Vec::new(),
            sentimental_items: Vec::new(),
            ui_configs: HashMap::new(),
            dialogue_trees: HashMap::new(),
            audio_configs: HashMap::new(),
            decay_rules: HashMap::new(),
            mount_personalities: HashMap::new(),
            bonding_mechanics: Value::Null,
        };
        
        // Try to load from OUT_DIR first (build-time generation)
        // Fall back to assets/ directory for pre-generated content
        let base_path = if let Ok(out_dir) = std::env::var("OUT_DIR") {
            PathBuf::from(out_dir)
        } else {
            PathBuf::from("assets/generated")
        };
        
        // Load hex worlds from MapsAgent
        for dread_level in 0..=4 {
            let world_path = base_path.join(format!("maps/hex_world_dread_{}.json", dread_level));
            if let Ok(content) = fs::read_to_string(&world_path) {
                if let Ok(json) = serde_json::from_str(&content) {
                    assets.hex_worlds.insert(dread_level, json);
                }
            }
        }
        
        // Load encounters from LevelsAgent
        let encounters_path = base_path.join("levels/encounters.json");
        if let Ok(content) = fs::read_to_string(&encounters_path) {
            if let Ok(json) = serde_json::from_str(&content) {
                assets.encounters = json;
            }
        }
        
        // Load sentimental items from LevelsAgent
        let items_path = base_path.join("levels/sentimental_items.json");
        if let Ok(content) = fs::read_to_string(&items_path) {
            if let Ok(json) = serde_json::from_str(&content) {
                assets.sentimental_items = json;
            }
        }
        
        // Load UI configurations from UIAgent
        for dread_level in 0..=4 {
            let ui_path = base_path.join(format!("ui/dread_{}.json", dread_level));
            if let Ok(content) = fs::read_to_string(&ui_path) {
                if let Ok(json) = serde_json::from_str(&content) {
                    assets.ui_configs.insert(dread_level, json);
                }
            }
        }
        
        // Load dialogue trees from DialogueAgent
        let dialogue_path = base_path.join("dialogue");
        if let Ok(entries) = fs::read_dir(&dialogue_path) {
            for entry in entries.flatten() {
                if let Some(name) = entry.file_name().to_str() {
                    if name.ends_with(".json") {
                        let character = name.trim_end_matches(".json");
                        if let Ok(content) = fs::read_to_string(entry.path()) {
                            if let Ok(json) = serde_json::from_str(&content) {
                                assets.dialogue_trees.insert(character.to_string(), json);
                            }
                        }
                    }
                }
            }
        }
        
        // Load audio configurations from AudioAgent
        for dread_level in 0..=4 {
            let audio_path = base_path.join(format!("audio/dread_{}.json", dread_level));
            if let Ok(content) = fs::read_to_string(&audio_path) {
                if let Ok(json) = serde_json::from_str(&content) {
                    assets.audio_configs.insert(dread_level, json);
                }
            }
        }
        
        // Load decay rules from DecayAgent
        for dread_level in 0..=4 {
            let decay_path = base_path.join(format!("decay/corruption_rules_dread_{}.json", dread_level));
            if let Ok(content) = fs::read_to_string(&decay_path) {
                if let Ok(json) = serde_json::from_str(&content) {
                    assets.decay_rules.insert(dread_level, json);
                }
            }
        }
        
        // Load mount data from MountAgent
        let personalities_path = base_path.join("mounts/personalities.json");
        if let Ok(content) = fs::read_to_string(&personalities_path) {
            if let Ok(json) = serde_json::from_str::<HashMap<String, Value>>(&content) {
                assets.mount_personalities = json;
            }
        }
        
        let bonding_path = base_path.join("mounts/bonding_mechanics.json");
        if let Ok(content) = fs::read_to_string(&bonding_path) {
            if let Ok(json) = serde_json::from_str(&content) {
                assets.bonding_mechanics = json;
            }
        }
        
        info!("Loaded AI-generated assets:");
        info!("  - {} hex worlds", assets.hex_worlds.len());
        info!("  - {} encounters", assets.encounters.len());
        info!("  - {} sentimental items", assets.sentimental_items.len());
        info!("  - {} UI configurations", assets.ui_configs.len());
        info!("  - {} dialogue trees", assets.dialogue_trees.len());
        info!("  - {} audio configurations", assets.audio_configs.len());
        info!("  - {} decay rule sets", assets.decay_rules.len());
        info!("  - {} mount personalities", assets.mount_personalities.len());
        
        assets
    }
    
    /// Get hex world data for current dread level
    pub fn get_hex_world(&self, dread_level: u8) -> Option<&Value> {
        self.hex_worlds.get(&dread_level)
    }
    
    /// Get UI configuration for current dread level
    pub fn get_ui_config(&self, dread_level: u8) -> Option<&Value> {
        self.ui_configs.get(&dread_level)
    }
    
    /// Get audio configuration for current dread level
    pub fn get_audio_config(&self, dread_level: u8) -> Option<&Value> {
        self.audio_configs.get(&dread_level)
    }
    
    /// Get decay rules for current dread level
    pub fn get_decay_rules(&self, dread_level: u8) -> Option<&Value> {
        self.decay_rules.get(&dread_level)
    }
    
    /// Get dialogue tree for a specific character
    pub fn get_dialogue_tree(&self, character: &str) -> Option<&Value> {
        self.dialogue_trees.get(character)
    }
}

/// Plugin to handle AI-generated assets
pub struct AIAssetsPlugin;

impl Plugin for AIAssetsPlugin {
    fn build(&self, app: &mut App) {
        app
            .add_systems(PreStartup, load_ai_assets)
            .add_systems(Update, apply_dread_responsive_assets);
    }
}

/// Load AI assets at startup
fn load_ai_assets(mut commands: Commands) {
    let assets = AIGeneratedAssets::load();
    
    let total_assets = 
        assets.hex_worlds.len() + 
        assets.encounters.len() + 
        assets.sentimental_items.len() +
        assets.ui_configs.len() +
        assets.dialogue_trees.len() +
        assets.audio_configs.len() +
        assets.decay_rules.len() +
        assets.mount_personalities.len();
    
    info!("Loaded {} total AI-generated assets", total_assets);
    
    commands.insert_resource(assets);
}

/// Apply dread-responsive assets when dread level changes
fn apply_dread_responsive_assets(
    dread: Res<crate::resources::DreadState>,
    assets: Res<AIGeneratedAssets>,
    mut ui_query: Query<&mut crate::components::UIConfig>,
    audio: Res<Audio>,
) {
    if !dread.is_changed() {
        return;
    }
    
    let current_dread = dread.current_level();
    
    // Update UI configuration
    if let Some(ui_config) = assets.get_ui_config(current_dread) {
        for mut ui in ui_query.iter_mut() {
            // Apply the configuration
            if let Some(opacity) = ui_config.get("opacity").and_then(|v| v.as_f64()) {
                ui.opacity = opacity as f32;
            }
            if let Some(corruption) = ui_config.get("corruption_overlay").and_then(|v| v.as_f64()) {
                ui.corruption_level = corruption as f32;
            }
        }
    }
    
    // Update audio configuration
    if let Some(audio_config) = assets.get_audio_config(current_dread) {
        // Apply audio changes based on configuration
        if let Some(volume) = audio_config.get("ambient_volume").and_then(|v| v.as_f64()) {
            // audio.set_volume(volume as f32);
        }
    }
    
    // Decay rules are handled by the decay system
    // Dialogue trees are used by the dialogue system
    // etc.
}