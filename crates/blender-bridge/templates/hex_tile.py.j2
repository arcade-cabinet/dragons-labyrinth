# Hex Tile Generation Template
# Asset: {{ name }} - {{ description }}

import bpy
import os
from mathutils import Vector

# Clear existing objects
bpy.ops.object.select_all(action='SELECT')
bpy.ops.object.delete(use_global=False)

# Create hex tile base geometry
{% if base_geometry == "hexagon_flat" %}
bpy.ops.mesh.primitive_cylinder_add(vertices=6, radius=1.0, depth=0.2)
{% elif base_geometry == "hexagon_elevated" %}
bpy.ops.mesh.primitive_cylinder_add(vertices=6, radius=1.0, depth=0.4)
bpy.context.active_object.location.z = 0.2
{% elif base_geometry == "hexagon_depressed" %}
bpy.ops.mesh.primitive_cylinder_add(vertices=6, radius=1.0, depth=0.1)
bpy.context.active_object.location.z = -0.1
{% elif base_geometry == "hexagon_ruined" %}
bpy.ops.mesh.primitive_cylinder_add(vertices=6, radius=1.0, depth=0.3)
# Add some mesh deformation for ruins effect
bpy.ops.object.mode_set(mode='EDIT')
bpy.ops.mesh.subdivide(number_cuts=2)
bpy.ops.transform.vertex_random(offset=0.1)
bpy.ops.object.mode_set(mode='OBJECT')
{% endif %}

hex_tile = bpy.context.active_object
hex_tile.name = "{{ name }}"

# Create material
material = bpy.data.materials.new(name="{{ name }}_material")
material.use_nodes = True
hex_tile.data.materials.append(material)

# Get material node tree
nodes = material.node_tree.nodes
links = material.node_tree.links

# Clear default nodes
for node in nodes:
    nodes.remove(node)

# Add principled BSDF
bsdf = nodes.new(type='ShaderNodeBsdfPrincipled')
output = nodes.new(type='ShaderNodeOutputMaterial')
links.new(bsdf.outputs['BSDF'], output.inputs['Surface'])

# Primary texture
{% if primary_texture %}
if os.path.exists("{{ texture_base_path }}/{{ primary_texture }}"):
    primary_tex = nodes.new(type='ShaderNodeTexImage')
    primary_tex.image = bpy.data.images.load("{{ texture_base_path }}/{{ primary_texture }}")
    links.new(primary_tex.outputs['Color'], bsdf.inputs['Base Color'])
{% endif %}

# Detail textures
{% for detail_texture in detail_textures %}
if os.path.exists("{{ texture_base_path }}/{{ detail_texture }}"):
    detail_tex_{{ loop.index }} = nodes.new(type='ShaderNodeTexImage')
    detail_tex_{{ loop.index }}.image = bpy.data.images.load("{{ texture_base_path }}/{{ detail_texture }}")
    
    # Mix with primary texture
    mix_node_{{ loop.index }} = nodes.new(type='ShaderNodeMixRGB')
    mix_node_{{ loop.index }}.blend_type = 'MULTIPLY'
    mix_node_{{ loop.index }}.inputs['Fac'].default_value = 0.5
    
    # Connect to mix chain
    {% if loop.index == 1 %}
    links.new(primary_tex.outputs['Color'], mix_node_{{ loop.index }}.inputs['Color1'])
    {% else %}
    links.new(mix_node_{{ loop.index - 1 }}.outputs['Color'], mix_node_{{ loop.index }}.inputs['Color1'])
    {% endif %}
    links.new(detail_tex_{{ loop.index }}.outputs['Color'], mix_node_{{ loop.index }}.inputs['Color2'])
    
    {% if loop.last %}
    links.new(mix_node_{{ loop.index }}.outputs['Color'], bsdf.inputs['Base Color'])
    {% endif %}
{% endfor %}

# Height variation
{% if height_variation %}
# Add displacement for height variation
displacement = nodes.new(type='ShaderNodeDisplacement')
noise_tex = nodes.new(type='ShaderNodeTexNoise')
noise_tex.inputs['Scale'].default_value = 5.0
noise_tex.inputs['Detail'].default_value = 2.0
noise_tex.inputs['Roughness'].default_value = 0.5

mapping = nodes.new(type='ShaderNodeMapping')
coord = nodes.new(type='ShaderNodeTexCoord')

links.new(coord.outputs['Generated'], mapping.inputs['Vector'])
links.new(mapping.outputs['Vector'], noise_tex.inputs['Vector'])
links.new(noise_tex.outputs['Fac'], displacement.inputs['Height'])
displacement.inputs['Scale'].default_value = {{ height_variation }}
links.new(displacement.outputs['Displacement'], output.inputs['Displacement'])
{% endif %}

# Apply generation parameters
{% if generation.subdivision_level %}
bpy.ops.object.mode_set(mode='EDIT')
bpy.ops.mesh.subdivide(number_cuts={{ generation.subdivision_level }})
bpy.ops.object.mode_set(mode='OBJECT')
{% endif %}

{% if generation.edge_smoothing %}
bpy.ops.object.shade_smooth()
{% endif %}

# Export to GLB
output_path = "{{ output_path }}"
os.makedirs(os.path.dirname(output_path), exist_ok=True)
bpy.ops.export_scene.gltf(
    filepath=output_path,
    export_format='GLB',
    {% if generation.optimize_for_mobile %}
    export_draco_mesh_compression_enable=True,
    export_draco_mesh_compression_level=6,
    {% endif %}
    use_selection=False
)

print(f"Generated hex tile: {{ name }} -> {output_path}")
