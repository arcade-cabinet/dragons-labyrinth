# Dragon's Labyrinth - Architecture Decision Records

## Overview

This document records the key architectural decisions made during the Dragon's Labyrinth project development. Each decision is documented with context, rationale, alternatives considered, and consequences to ensure future developers understand the reasoning behind the current architecture.

## ADR-001: Clean Separation Architecture

**Date**: January 2025  
**Status**: ✅ ACCEPTED  
**Decision Makers**: Project Team  

### Context
Traditional game development embeds content generation directly in game code, creating complex dependencies and performance issues. AI-generated content requires sophisticated processing that doesn't belong in runtime game engines.

### Decision
Implement complete architectural separation:
- **Build-Time**: Python agentic workflows using LangGraph + SQLite for AI content generation
- **Runtime**: Pure Rust game engine using Bevy that only consumes generated assets
- **Interface**: Database and file system as communication layer

### Rationale
1. **Performance**: Runtime engine has zero AI overhead
2. **Maintainability**: Clear separation of concerns
3. **Scalability**: AI generation can run on separate infrastructure
4. **Development**: Parallel development of generation and consumption systems
5. **Testing**: Each layer can be tested independently

### Alternatives Considered
- **Embedded AI**: Include AI generation in Rust game engine
  - Rejected: Performance impact, architectural complexity
- **Microservices**: Separate AI services with API communication
  - Rejected: Over-engineering for single-player game
- **Hybrid Approach**: Some AI in runtime for dynamic content
  - Rejected: Breaks clean separation, adds complexity

### Consequences
✅ **Positive**:
- Clean, maintainable architecture
- Runtime performance optimization possible
- Independent testing and development
- Clear responsibility boundaries

⚠️ **Negative**:
- Two-language codebase (Python + Rust)
- Build process complexity
- Communication protocol needed between layers

### Implementation
```
Build-Time (Python)           Runtime (Rust)
├── LangGraph AI Agents  ←→   ├── Bevy ECS Systems
├── SQLite Job Queues    ←→   ├── Asset Loading
├── Asset Generation     ←→   ├── Game Logic
└── Human Review         ←→   └── Performance Focus
```

---

## ADR-002: Three-Tier Asset Strategy

**Date**: January 2025  
**Status**: ✅ ACCEPTED  
**Decision Makers**: Project Team

### Context
AI generation is expensive and time-consuming. Many high-quality CC0 assets exist that could be reused. Need to balance quality, cost, and uniqueness.

### Decision
Implement three-tier asset strategy:
1. **Core Assets (Sacred)**: Hand-crafted intro/outro videos, signature sounds - AI never touches
2. **Library Assets (CC0)**: Professional CC0 collection - AI searches and reuses intelligently  
3. **Generated Assets (AI)**: Horror-specific variants and game-unique content - AI fills gaps

Target ratio: 80% reuse + 20% generation

### Rationale
1. **Cost Efficiency**: 80% cost reduction vs full AI generation
2. **Quality**: Professional CC0 assets often higher quality than AI
3. **Uniqueness**: AI focuses on horror-specific content where uniqueness matters
4. **Speed**: Faster development with existing asset base
5. **Consistency**: AI can enhance existing assets for visual coherence

### Alternatives Considered
- **100% AI Generation**: All assets generated by AI
  - Rejected: Expensive, time-consuming, lower average quality
- **100% CC0 Reuse**: Only use existing assets
  - Rejected: Insufficient horror-specific content, generic feel
- **50/50 Split**: Equal generation and reuse
  - Rejected: Not optimal cost/benefit ratio

### Consequences
✅ **Positive**:
- Massive cost savings (estimated 80% reduction)
- Professional quality baseline
- Faster content pipeline
- Focus AI on unique horror elements

⚠️ **Negative**:
- Complex asset search and classification system
- Need robust attribution tracking
- Potential style inconsistencies between tiers

### Implementation
```rust
// Asset selection logic
fn select_asset(requirements: AssetRequirement) -> AssetResult {
    // Tier 1: Check core assets (sacred)
    if let Some(core) = check_core_assets(requirements) {
        return AssetResult::core(core);
    }
    
    // Tier 2: Search CC0 library
    if let Some(library) = search_cc0_library(requirements) {
        if suitability_score(library) > 0.8 {
            return AssetResult::library(library);
        } else if suitability_score(library) > 0.5 {
            return AssetResult::enhanced(library, plan_ai_enhancements());
        }
    }
    
    // Tier 3: AI generation
    AssetResult::generated(ai_generate_asset(requirements))
}
```

---

## ADR-003: Database Architecture (OUT_DIR Location)

**Date**: January 2025  
**Status**: ✅ ACCEPTED (Correcting Previous Implementation)  
**Decision Makers**: Project Team

### Context
Initial implementation placed SQLite database in XDG user directories. User clarified that database should be created in OUT_DIR to ship with the release. Structured tools were placed in build-tools but should be in game-database runtime layer.

### Decision
- **Database Location**: Create SQLite database in OUT_DIR during build
- **Tool Location**: Move structured tools to game-database runtime layer
- **Communication**: game-database provides bidirectional interface between Python AI and Rust runtime

### Rationale
1. **Distribution**: Database ships with game, no external dependencies
2. **Architecture**: Structured tools belong in data layer, not build layer  
3. **Single Source**: game-database is authoritative source for all data operations
4. **Build Integration**: OUT_DIR naturally includes database in release

### Alternatives Considered
- **XDG Directory**: Database in user-specific directory
  - Rejected: User clarified this was wrong, database should ship with game
- **Tools in Build-Tools**: Keep structured tools in build-tools
  - Rejected: Violates separation of concerns, tools are data operations
- **Separate Database Crate**: Database crate independent of game-database
  - Rejected: Duplicates functionality, increases complexity

### Consequences
✅ **Positive**:
- Database ships with game (no setup required)
- Clean architectural boundaries
- Single source of truth for data operations
- Proper build-time vs runtime separation

⚠️ **Negative**:
- Need to migrate existing implementation
- Database size included in game download
- Build process must handle database creation

### Implementation Changes Required
```rust
// game-database/build.rs
fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let db_path = format!("{}/game.db", out_dir);
    create_database(&db_path).expect("Database creation failed");
}

// game-database/src/tools.rs (MOVED FROM build-tools)
pub fn create_structured_tools() -> Vec<Tool> {
    // All database tools defined here
}

// game-engine/build.rs  
fn main() {
    // Database already created by game-database build.rs
    let out_dir = env::var("OUT_DIR").unwrap();
    let db_url = format!("sqlite://{}/game.db", out_dir);
    
    let mut context = BuildContext::new(&out_dir).await?;
    context.connect_database(&db_url).await?;
    // Generate content using database
}
```

---

## ADR-004: Rust/Bevy Technology Stack

**Date**: January 2025  
**Status**: ✅ ACCEPTED  
**Decision Makers**: Project Team

### Context
Need to select technology stack for runtime game engine. Requirements: high performance, mobile support, ECS architecture, WebAssembly compilation, active ecosystem.

### Decision
- **Language**: Rust (Edition 2021)
- **Game Engine**: Bevy 0.16.1
- **Architecture**: Entity Component System (ECS)
- **Platform Targets**: Native (Windows/Linux/Mac) + WebAssembly
- **Specialty Crates**: Hexx (hex grid), bevy_yarnspinner (dialogue), cobweb-ui (UI)

### Rationale
1. **Performance**: Rust provides C++ level performance with memory safety
2. **ECS Architecture**: Natural fit for horror progression systems
3. **WebAssembly**: First-class web deployment support
4. **Mobile**: Strong mobile performance with wgpu graphics
5. **Ecosystem**: Rich crate ecosystem for specialized functionality
6. **Horror Integration**: ECS perfect for component-based corruption systems

### Alternatives Considered
- **Godot 4**: Excellent 2D/3D, GDScript simplicity
  - Rejected: Less performance than Rust, not as good for mobile
- **Unity**: Large ecosystem, mature tooling
  - Rejected: Licensing concerns, C# not as performant as Rust
- **Unreal**: AAA quality, Blueprint system
  - Rejected: Overkill for project scope, poor web deployment
- **Custom C++**: Maximum performance and control
  - Rejected: Development time, memory safety concerns

### Consequences
✅ **Positive**:
- Excellent performance on all target platforms
- Memory safety prevents many common game bugs
- ECS architecture natural for horror progression
- Strong WebAssembly story
- Active community and development

⚠️ **Negative**:
- Steeper learning curve than scripted engines
- Compile times longer than interpreted languages
- Smaller asset marketplace than Unity
- ECS paradigm unfamiliar to some developers

### Implementation
```rust
// Core Bevy app structure
fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(HexBoardPlugin)    // Hexx integration
        .add_plugins(YarnSpinnerPlugin) // Dialogue system
        .add_plugins(CobwebUiPlugin)    // UI system
        .add_systems(Startup, setup_world)
        .add_systems(Update, (
            horror_progression_system,
            companion_trauma_system,
            corruption_system,
        ).chain())
        .run();
}
```

---

## ADR-005: Specialized AI Agent Architecture

**Date**: January 2025  
**Status**: ✅ ACCEPTED  
**Decision Makers**: Project Team

### Context
Need to design AI agent system for content generation. Options range from single general-purpose agent to highly specialized domain agents.

### Decision
Implement 5 specialized AI agents:
- **MapsAgent**: Hex world generation, biome corruption progression  
- **LevelsAgent**: Yoleck encounter placement, interactive objects
- **UIAgent**: Cobweb horror-responsive interface degradation
- **DialogueAgent**: YarnSpinner companion arcs, moral choice trees
- **AudioAgent**: Freesound integration, proximity horror, spatial audio

### Rationale
1. **Expertise**: Each agent specializes in specific game systems
2. **Parallel Processing**: Agents can work simultaneously on different content
3. **Quality**: Specialized prompts produce better domain-specific content
4. **Maintainability**: Clear boundaries and responsibilities
5. **Horror Integration**: Each agent understands its role in horror progression

### Alternatives Considered
- **Single General Agent**: One agent generates all content
  - Rejected: Jack of all trades, master of none - quality suffers
- **Two-Tier System**: General agent with specialized sub-agents
  - Rejected: Added complexity without clear benefits
- **Micro-Agents**: 15+ highly specialized agents
  - Rejected: Too much coordination overhead

### Consequences
✅ **Positive**:
- High-quality domain-specific content
- Parallel generation capability
- Clear architectural boundaries
- Easier testing and validation
- Horror progression expertise per domain

⚠️ **Negative**:
- Need coordination between agents
- Potential content inconsistencies
- More complex orchestration
- Higher initial development cost

### Implementation
```python
class DragonAgent(BaseAgent):
    def __init__(self, domain: str):
        self.domain = domain  # "maps", "levels", "ui", "dialogue", "audio"
        self.horror_awareness = True
        self.dread_progression = DreadProgression()
        
    async def generate(self, context: BuildContext, request: GenerationRequest):
        # Domain-specific generation with horror integration
        result = await self.domain_specific_generation(context, request)
        result.apply_horror_progression(request.dread_level)
        return result
```

---

## ADR-006: Horror-First Design Principle

**Date**: January 2025  
**Status**: ✅ ACCEPTED  
**Decision Makers**: Project Team

### Context
Need to establish core design philosophy that guides all technical and creative decisions. Traditional RPGs focus on power progression; this game is fundamentally different.

### Decision
Establish "Horror-First Design Principle":
- This is NOT "an RPG with horror elements"
- This IS "a horror experience that uses RPG mechanics"
- EVERY system, feature, and asset must serve the horror narrative
- The emotional journey (Peace → Horror) IS the game orchestrator

### Rationale
1. **Vision Clarity**: Prevents feature creep and scope drift
2. **Decision Framework**: Clear criteria for all design decisions
3. **Unique Value**: Differentiates from traditional RPGs
4. **Emotional Impact**: Ensures genuine horror experience
5. **System Coherence**: All components work toward same goal

### Alternatives Considered
- **RPG-First**: Focus on traditional RPG mechanics with horror flavor
  - Rejected: Generic, doesn't serve unique vision
- **Balanced Approach**: Equal weight to RPG and horror elements
  - Rejected: Dilutes both experiences, lacks focus
- **Genre-Agnostic**: Build flexible system supporting multiple genres
  - Rejected: Generic systems don't excel at horror

### Consequences
✅ **Positive**:
- Clear design direction for all decisions
- Unique market positioning
- Coherent player experience
- Strong emotional impact
- Prevents scope creep

⚠️ **Negative**:
- May alienate traditional RPG players
- Limits some traditional RPG features
- Requires more sophisticated narrative integration
- Higher design complexity

### Implementation Guidelines
```
Decision Framework:
1. Does this serve the horror progression? (Required: YES)
2. Does this enhance emotional impact? (Preferred: YES)  
3. Would traditional RPG players expect this? (Acceptable: NO)
4. Does this maintain narrative coherence? (Required: YES)

Examples:
- Player Power: Gets weaker (serves horror) ✅
- Companions: Break under pressure (serves horror) ✅
- Economy: Collapses with dread (serves horror) ✅
- Combat: Victory feels hollow (serves horror) ✅
```

---

## ADR-007: Idempotent Generation Strategy

**Date**: January 2025  
**Status**: ✅ ACCEPTED  
**Decision Makers**: Project Team

### Context
AI generation is non-deterministic by nature, but game development requires reproducible builds and version control. Need strategy for making AI generation deterministic and repeatable.

### Decision
Implement comprehensive idempotent generation:
- **Deterministic IDs**: Content-based hashing for all generated entities
- **Seed Control**: Fixed seeds for AI models based on input parameters
- **Caching**: Aggressive caching with content-addressable storage
- **Version Control**: Generated assets tracked alongside source code

### Rationale
1. **Reproducible Builds**: Same inputs always produce compatible outputs
2. **Version Control**: Generated content can be committed and diffed
3. **Collaboration**: Multiple developers get same generated content
4. **Testing**: Deterministic content enables reliable testing
5. **Deployment**: Predictable build artifacts for release

### Alternatives Considered
- **Accept Non-Determinism**: Let AI generate different content each time
  - Rejected: Makes testing and collaboration impossible
- **Pre-Generate All**: Generate all content once, never regenerate
  - Rejected: Prevents iteration and improvement
- **Hybrid Approach**: Some content deterministic, some not
  - Rejected: Inconsistent, confusing for developers

### Consequences
✅ **Positive**:
- Reliable, reproducible development process
- Version control integration
- Collaborative development possible
- Deterministic testing
- Predictable deployment

⚠️ **Negative**:
- Limits AI creativity/variation
- Complex caching infrastructure required
- Large version control repository
- Potential for cache invalidation issues

### Implementation
```rust
// Deterministic ID generation
fn generate_asset_id(asset_type: &str, parameters: &AssetParams) -> String {
    let mut hasher = DefaultHasher::new();
    asset_type.hash(&mut hasher);
    parameters.hash(&mut hasher);
    format!("asset_{:016x}", hasher.finish())
}

// Content-addressable caching
fn cache_generated_content(id: &str, content: &GeneratedContent) -> Result<()> {
    let cache_key = format!("cache/{}/{}", id, content.content_hash());
    fs::write(cache_key, content.serialize())?;
    Ok(())
}
```

---

## ADR-008: Task Delegation System

**Date**: January 2025  
**Status**: ✅ ACCEPTED  
**Decision Makers**: Project Team

### Context
Large project scope requires parallel development by multiple specialized agents/developers. Need clear organization system for task distribution based on capabilities and complexity.

### Decision
Implement four-tier task delegation system:
1. **Advanced Foreground Agents** (Claude 3.5 Sonnet/Opus): Complex architectural decisions, cross-crate integration
2. **Standard Sonnet Agents**: Feature implementation, module creation
3. **Sonnet 1M Context Agents**: Large file analysis, narrative synthesis  
4. **Cursor Background Agents**: TOML generation, structured repetitive work

### Rationale
1. **Capability Matching**: Tasks assigned based on agent capabilities
2. **Parallel Execution**: Multiple agents can work simultaneously
3. **Quality Control**: Complex tasks go to most capable agents
4. **Efficiency**: Repetitive tasks handled by specialized background agents
5. **Clear Boundaries**: Well-defined responsibility areas

### Alternatives Considered
- **Single Developer**: One person handles all tasks
  - Rejected: Too slow for project scope
- **Equal Distribution**: All agents handle all task types
  - Rejected: Inefficient, quality varies by agent capability
- **Two-Tier System**: Only foreground and background agents
  - Rejected: Too broad, doesn't utilize specialized capabilities

### Consequences
✅ **Positive**:
- Optimal task-to-capability matching
- Parallel development possible
- High quality for complex tasks
- Efficient handling of repetitive work
- Clear responsibility boundaries

⚠️ **Negative**:
- Requires careful coordination
- Risk of communication gaps
- Complex task dependency management
- Need clear documentation standards

### Implementation
```yaml
Task Categories:
AF (Advanced Foreground):
  - Complex architecture (AF-001, AF-002, AF-003)
  - Cross-system integration
  - Critical path decisions

S1M (Sonnet 1M Context):  
  - Narrative synthesis (S1M-001)
  - Large document analysis
  - Complete system synthesis

SS (Standard Sonnet):
  - Feature implementation
  - Module development  
  - API integration

CB (Cursor Background):
  - TOML generation (CB-001)
  - Batch processing
  - Structured rule creation
```

---

## ADR-009: Expanded Vision Integration Strategy

**Date**: January 2025  
**Status**: ✅ ACCEPTED (Phased Approach)  
**Decision Makers**: Project Team

### Context
Original design included sophisticated systems (Dual Forge, Sentimental Items, Companion Personal Quests, Dynamic Economy) that were cut for MVP. Current architecture can support these features. Need decision on integration timing.

### Decision
Implement **Phased Integration Strategy**:

**Phase 1 (Immediate Integration)**:
- Sentimental Items System ⭐⭐⭐⭐⭐ (+1 week)
- Basic Forge System ⭐⭐⭐⭐⭐ (+2 weeks)

**Phase 2 (Post-MVP)**:
- Dual Forge System (Light/Dark paths) (+1 week)
- Companion Personal Quests ⭐⭐⭐⭐ (+2 weeks)

**Phase 3 (Future Enhancement)**:
- Dynamic Economy System ⭐⭐⭐ (+1 week)
- Environmental Storytelling ⭐⭐⭐ (+1 week)

### Rationale
1. **Impact**: Sentimental Items and Forge provide maximum narrative impact
2. **Risk**: Phased approach manages development risk
3. **Architecture**: Current design supports all features
4. **Resources**: Manageable development time addition
5. **Value**: +60% estimated player engagement for 7 weeks development

### Alternatives Considered
- **All Features Immediately**: Integrate everything at once
  - Rejected: Too risky, might delay MVP
- **No Expanded Features**: Stick to minimal scope
  - Rejected: Misses major opportunities for impact
- **Different Priority Order**: Alternative feature prioritization
  - Rejected: Analysis shows current order is optimal

### Consequences
✅ **Positive**:
- Major enhancement to player experience
- Manageable development timeline
- Risk mitigation through phasing
- Clear stopping points if needed
- Significant competitive advantage

⚠️ **Negative**:
- Extended development timeline
- Increased complexity
- More testing required
- Potential scope creep risk

### Implementation Plan
```yaml
Phase 1 (7 weeks total timeline):
Week 1-4: Core MVP development
Week 5-6: Sentimental Items + Basic Forge
Week 7: Integration and testing

Phase 2 (Post-MVP):
- Dual Forge paths
- Companion personal stories
- Advanced relationship mechanics

Phase 3 (If successful):
- Economic simulation
- Environmental narrative
- Advanced world systems
```

---

## ADR-010: Build Dependencies Architecture

**Date**: January 2025  
**Status**: ✅ ACCEPTED (User Clarification)  
**Decision Makers**: Project Team

### Context
Initial concern about circular dependencies between game-engine and build-tools. User clarified that build-dependencies do not create circular dependencies since they only exist at compile time.

### Decision
- **game-engine** CAN have **build-tools** as build-dependency
- **Generated code** goes in OUT_DIR, not src/
- **Build process** passes OUT_DIR to build-tools for generation target
- **Runtime** includes generated code from OUT_DIR

### Rationale
1. **No Circular Dependency**: Build-dependencies are compile-time only
2. **Clean Separation**: Generated code separate from source code
3. **Build Integration**: Natural Cargo build system usage
4. **Rust Patterns**: Follows standard Rust build.rs patterns

### Alternatives Considered
- **Separate Build Step**: External build script before Cargo
  - Rejected: Less integrated, more complex workflow
- **Generated Code in src/**: Put generated code in source directory
  - Rejected: Pollutes source tree, version control issues

### Consequences
✅ **Positive**:
- Natural Cargo integration
- Clean build process
- Generated code properly isolated
- Standard Rust patterns

⚠️ **Negative**:
- Build process complexity
- Need to understand OUT_DIR mechanics
- Generated code not easily inspectable

### Implementation
```rust
// game-engine/Cargo.toml
[build-dependencies]
build-tools = { path = "../build-tools" }
game-database = { path = "../game-database" }

// game-engine/build.rs
fn main() {
    let out_dir = env::var("OUT_DIR")?;
    build_tools::generate_all(&out_dir)?;
}

// game-engine/src/generated.rs
include!(concat!(env!("OUT_DIR"), "/generated/maps.rs"));
include!(concat!(env!("OUT_DIR"), "/generated/encounters.rs"));
```

---

## Decision Summary

| ADR | Decision | Status | Impact |
|-----|----------|--------|---------|
| 001 | Clean Separation Architecture | ✅ ACCEPTED | HIGH |
| 002 | Three-Tier Asset Strategy | ✅ ACCEPTED | HIGH |
| 003 | Database in OUT_DIR | ✅ ACCEPTED | MEDIUM |
| 004 | Rust/Bevy Technology Stack | ✅ ACCEPTED | HIGH |
| 005 | Specialized AI Agents | ✅ ACCEPTED | MEDIUM |
| 006 | Horror-First Design Principle | ✅ ACCEPTED | HIGH |
| 007 | Idempotent Generation | ✅ ACCEPTED | MEDIUM |
| 008 | Task Delegation System | ✅ ACCEPTED | MEDIUM |
| 009 | Expanded Vision Phased Integration | ✅ ACCEPTED | HIGH |
| 010 | Build Dependencies Architecture | ✅ ACCEPTED | MEDIUM |

## Implementation Priority

**Immediate Implementation Required**:
- ADR-003: Fix database architecture (AF-003)
- ADR-010: Wire build dependencies (AF-002)
- ADR-005: Complete AI agent implementation (AF-001)

**Foundation Decisions (Already Driving Development)**:
- ADR-001: Clean separation architecture
- ADR-002: Three-tier asset strategy  
- ADR-006: Horror-first design principle

**Ongoing Implementation**:
- ADR-007: Idempotent generation systems
- ADR-008: Task delegation execution
- ADR-009: Expanded vision integration

## Future Decision Points

**Decisions That May Need Revisiting**:
1. **Technology Stack**: If Bevy ecosystem proves insufficient
2. **Asset Strategy**: If 80/20 ratio proves suboptimal
3. **Agent Architecture**: If coordination becomes problematic
4. **Expanded Vision**: If development timeline pressures increase

**Success Metrics for Validation**:
- Development velocity and quality
- System performance benchmarks
- Horror progression effectiveness
- Player engagement metrics

These architectural decisions form the foundation of Dragon's Labyrinth and should guide all future development work. Any changes to these decisions should follow the same rigorous documentation process to maintain architectural coherence.
