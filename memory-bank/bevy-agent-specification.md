# Dragon's Labyrinth - Bevy Agent Specification

## Project Overview
Dragon's Labyrinth is a horror RPG with inverted power mechanics, procedurally generated hex world, and companion trauma systems. This specification defines how to use bevy-agent to generate the Rust/Bevy code from our Python-generated worldbuilding data.

## Architecture Strategy

### Current Pipeline
```
Markdown → Python AI → JSON Data → [MANUAL RUST CODE] → Game
```

### New Pipeline with bevy-agent
```
Markdown → Python AI → JSON Data → bevy-agent → Generated Rust Code → Game
```

## Core Project Setup for bevy-agent

### 1. Initialize Project with bevy-agent
```bash
# Install bevy-agent
cargo install bevy-agent

# Configure API key
bevy-agent config --openai-key sk-...

# Create project with our specifications
bevy-agent create "Horror RPG with hex-based world, inverted combat where health is currency, companion trauma system, and forge redemption mechanics"
```

### 2. World Data Integration Requirements

The game must load and use our Python-generated worldbuilding:

```rust
// Resources to generate
#[derive(Resource, Deserialize)]
struct WorldBook {
    plan: WorldPlan,
    regions: Vec<Region>,
}

#[derive(Resource)]
struct AtlasData {
    texture: Handle<Image>,
    biome_mappings: HashMap<String, u32>,
}

// System to load worldbook.json
fn load_worldbook(mut commands: Commands) {
    let data = std::fs::read_to_string("build/world/worldbook.json").unwrap();
    let worldbook: WorldBook = serde_json::from_str(&data).unwrap();
    commands.insert_resource(worldbook);
}
```

## ECS Component Architecture

### Core Components
```rust
// Position & Movement
#[derive(Component)]
struct HexPosition { q: i32, r: i32 }

// Health System (Inverted)
#[derive(Component)]
struct Health {
    current: i32,
    max: i32,
    curse_multiplier: f32,
}

// Companion System
#[derive(Component)]
struct Companion {
    id: String,
    name: String,
    trauma_level: f32,
    breaking_points: Vec<TraumaEvent>,
    relationship: f32,
    dialogue_state: DialogueState,
}

// Tile Information
#[derive(Component)]
struct BiomeTile {
    biome_type: String,
    band: ProgressionBand,
    poi_type: Option<String>,
}

// Combat State
#[derive(Component)]
struct CombatStats {
    attack_cost: i32,    // HP cost to attack
    defend_cost: i32,    // HP cost to defend
    flee_cost: i32,      // HP cost to flee
}
```

### Resources
```rust
#[derive(Resource)]
struct CombatState {
    player_hp: i32,
    max_hp: i32,
    curse_level: f32,
    band: ProgressionBand,
    in_combat: bool,
    current_enemy: Option<Enemy>,
}

#[derive(Resource)]
struct ForgeState {
    uses_remaining: u32,
    redemption_cost: RedemptionCost,
}

#[derive(Resource)]
enum GameMode {
    Exploration,
    Combat,
    Dialogue,
    Forge,
    Dungeon,
}
```

## Systems to Generate

### 1. Movement System
```bash
bevy-agent add "Hex-based movement system using Q/W/E/A/S/D keys for a hex grid with axial coordinates. Must integrate with bevy_ecs_tilemap for hex rendering."
```

### 2. Combat System (Inverted)
```bash
bevy-agent add "Combat system where every action costs HP instead of dealing damage. Attacks cost 3-20 HP based on progression band. Victory reduces max HP permanently. Integrate with worldbook.json enemy data."
```

### 3. Companion Trauma System
```bash
bevy-agent add "Companion system with trauma tracking. Each companion has trauma level 0.0-1.0, breaking points that trigger permanent changes, and dialogue that changes based on trauma. Load companion data from worldbook.json."
```

### 4. Forge Redemption System
```bash
bevy-agent add "Forge system at shrine POIs where players can trade: 50% max HP to resurrect companion, companion to reset another's trauma, all items to restore 25% health. Limited uses per progression band."
```

### 5. World Loading System
```bash
bevy-agent add "System to load worldbook.json and spawn hex tilemap from region data. Use bevy_ecs_tilemap with texture atlas at build/atlas/atlas.png. Map biome names to texture indices."
```

### 6. Dungeon Generation
```bash
bevy-agent add "Procedural dungeon generation using mapgen crate. Generate dungeons at POIs marked as 'dungeon' in worldbook.json. Use cellular automata for organic cave layouts."
```

## Integration with Existing Assets

### Asset Paths
```
apps/game/assets/
├── biomes/          # 15 hex tiles generated by Python
├── icons/           # 8 POI icons
└── atlas/           # Combined texture atlas
    ├── atlas.png
    └── atlas.json
```

### Data Paths
```
build/
├── world/
│   └── worldbook.json   # Main world data
├── features/
│   └── shops/*.json     # Shop inventories
└── narrative/           # Dialogue trees (future)
```

## Crate Dependencies

```toml
[dependencies]
bevy = "0.16.1"
bevy_ecs_tilemap = "0.16.0"
mapgen = "0.6.0"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
rand = "0.8"
```

## Project Configuration for bevy-agent

Create `.bevy-agent.json`:
```json
{
  "project": {
    "name": "Dragon's Labyrinth",
    "description": "Horror RPG with inverted power mechanics",
    "bevy_version": "0.16.1",
    "features": [
      "hex_movement",
      "inverted_combat",
      "companion_trauma",
      "forge_redemption",
      "procedural_dungeons"
    ]
  },
  "generation": {
    "temperature": 0.7,
    "max_tokens": 4000,
    "model": "gpt-4",
    "include_comments": true
  },
  "custom_context": {
    "worldbook_path": "build/world/worldbook.json",
    "atlas_path": "build/atlas/atlas.png",
    "game_pillars": [
      "dread_escalation",
      "inverted_combat_economy",
      "companion_trauma",
      "post_dragon_collapse",
      "forge_second_chances"
    ]
  }
}
```

## Workflow

### Step 1: Generate World Content (Python)
```bash
# Generate worldbuilding from markdown
python -m ai canonize
python -m ai plan
python -m ai expand
python -m ai images
```

### Step 2: Initialize Game with bevy-agent
```bash
# Create initial game structure
bevy-agent create "Horror RPG with hex world loaded from build/world/worldbook.json"

# Add each system
bevy-agent add "hex movement with bevy_ecs_tilemap"
bevy-agent add "inverted combat system"
bevy-agent add "companion trauma tracking"
bevy-agent add "forge redemption mechanics"
```

### Step 3: Integrate Generated Code
```bash
# Build and test
cargo build
cargo run -p game

# Iterate with improvements
bevy-agent improve performance
bevy-agent improve structure
```

## Example Prompts for bevy-agent

### Complete World Loading
```
Create a system that loads build/world/worldbook.json and spawns a hex tilemap using bevy_ecs_tilemap. 
The worldbook contains regions with hex_points that specify POI locations. 
Each region has biomes that should map to texture indices in the atlas.
Use HexCoordSystem::Row and tile size 58x50 pixels.
```

### Combat Encounter System
```
Create a combat system where:
- Combat triggers when player enters a hex with POI type "lair" or "dungeon"
- Every action costs HP: attack costs vary by enemy, defend costs less, flee costs most
- Victory permanently reduces max HP by 5 + (progression_band * 2)
- Enemy strength scales with distance from origin (0,0)
- Display combat UI showing HP costs for each action
```

### Companion Dialogue System
```
Create a dialogue system for companions that:
- Loads dialogue from worldbook NPCs data
- Modifies dialogue based on companion trauma_level (0.0-1.0)
- Triggers breaking points at trauma thresholds (0.3, 0.6, 0.9)
- Changes relationship value based on player choices
- Integrates with combat outcomes affecting trauma
```

## Testing Strategy

### Unit Tests to Generate
```bash
bevy-agent add "unit tests for hex coordinate conversion"
bevy-agent add "unit tests for combat HP calculations"
bevy-agent add "unit tests for trauma progression"
```

### Integration Tests
```bash
bevy-agent add "integration test for worldbook loading"
bevy-agent add "integration test for combat encounter flow"
```

## Benefits of bevy-agent Approach

### Advantages
1. **Rapid Prototyping**: Generate working code in minutes
2. **Consistency**: AI understands Bevy patterns and ECS architecture
3. **Iteration Speed**: Quickly add features and improvements
4. **Documentation**: Generated code includes comments
5. **Best Practices**: AI follows Rust and Bevy conventions

### When to Use Manual Coding
- Core game loop modifications
- Custom shader implementation
- Performance-critical sections
- Unique mechanics not in training data

## Next Steps

1. **Install bevy-agent**: `cargo install bevy-agent`
2. **Configure API**: `bevy-agent config --openai-key sk-...`
3. **Generate Initial Game**: Use the complete world loading prompt
4. **Add Core Systems**: Generate each system incrementally
5. **Test Integration**: Verify worldbook data loads correctly
6. **Iterate**: Use `bevy-agent improve` for refinements

## Success Criteria

- [ ] Game loads worldbook.json successfully
- [ ] Hex movement works with Q/W/E/A/S/D
- [ ] Combat triggers at lair/dungeon POIs
- [ ] HP costs apply correctly in combat
- [ ] Companions track trauma levels
- [ ] Forge offers redemption choices
- [ ] Dungeons generate procedurally
- [ ] Game runs at 60 FPS

This specification provides everything bevy-agent needs to generate a working Dragon's Labyrinth game that integrates with our Python-generated worldbuilding data.
