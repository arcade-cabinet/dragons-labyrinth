{# ---- BEGIN templates/orchestrator/inventory_crafting_system.jinja2 ---- #}
# Generate Inventory and Crafting System

## Context
Create a comprehensive inventory and crafting system that integrates with the hex-based gameplay and discovered item assets. The system should encourage exploration and resource management while providing meaningful progression through crafted items.

## Inventory System

### 1. Inventory Layout
- **Grid Size**: 10x5 hexagonal slots (50 total)
- **Equipment Slots**: 
  - Head, Chest, Legs, Feet (Armor)
  - Main Hand, Off Hand (Weapons/Shield)
  - 2 Ring slots, 1 Amulet slot
  - 4 Quick-use slots (potions/consumables)
- **Weight System**: Optional encumbrance
- **Sorting Options**: By type, value, weight, name

### 2. Item Categories

Based on discovered item assets:
{% for item_type in discovered_items %}
- **{{ item_type.category }}**:
  - Examples: {{ item_type.items }}
  - Stack size: {{ item_type.stackable }}
  - Special properties: {{ item_type.properties }}
{% endfor %}

### 3. Item Rarity Tiers
- **Common** (Gray): Basic items, vendor trash
- **Uncommon** (Green): Slight stat improvements
- **Rare** (Blue): Notable upgrades, minor effects
- **Epic** (Purple): Significant bonuses, unique effects
- **Legendary** (Orange): Best-in-slot, game-changing
- **Mythic** (Red): Ultra-rare, requires special quests
- **Dragon-Forged** (Rainbow): Crafted from dragon parts

### 4. Class-Aware Loot System

#### Drop Rate Modifiers
```
Base Drop Rate × Class Affinity Modifier:

For player class items:
- Primary weapon type: 1.5x drop rate
- Primary armor type: 1.4x drop rate  
- Class-specific accessories: 1.3x drop rate

For other items:
- Universal items: 1.0x drop rate
- Crafting materials: 1.0x drop rate
- Opposite class items: 0.7x drop rate (for trading/selling)

Example for Archer:
- Bows/Crossbows: 45% drop chance (base 30% × 1.5)
- Light armor: 42% drop chance (base 30% × 1.4)
- Heavy armor: 21% drop chance (base 30% × 0.7)
```

#### Smart Loot Distribution
- First item drop prioritizes upgrades for equipped slots
- Subsequent drops vary to encourage diverse builds
- Boss drops guarantee at least one class-appropriate item
- Crafting materials drop regardless of class

### 4. Item Properties

#### Base Stats
- Damage/Defense values
- Stat bonuses (+STR, +INT, etc.)
- Elemental resistances
- Special effects (lifesteal, mana regen)

#### Modifiers
- Prefix: "Flaming", "Frozen", "Swift"
- Suffix: "of the Bear", "of Wisdom"
- Set bonuses: Collect full sets for extras
- Enchantment slots: Add custom effects

## Crafting System

### 1. Crafting Stations

#### Portable Crafting
- **Campfire**: Basic cooking, simple repairs
- **Workbench**: Field repairs, basic crafting
- **Alchemy Kit**: Potions on the go

#### Town Stations (Superior Results)
- **Forge**: Weapons and heavy armor
- **Loom**: Cloth and leather armor
- **Enchanting Table**: Add magical properties
- **Alchemy Lab**: Advanced potions
- **Jeweler**: Rings, amulets, gem cutting
- **Dragon Forge**: Ultimate crafting (late game)

### 2. Crafting Mechanics

#### Progressive Tutorial System
Level-based introduction to crafting:
```
Level 1-3: Material Introduction
- Hovering over materials shows tooltips
- "Iron Ore - Used for crafting weapons at a blacksmith"
- UI notification when inventory has crafting materials
- "Visit a blacksmith to learn about crafting!"

Level 3-5: First Crafting Experience
- Mandatory quest: "The Apprentice Blacksmith"
- NPC guides through crafting basic item
- Shows recipe preview interface
- Explains success rates and material requirements
- Rewards: Basic crafted item + recipe book

Level 5+: Advanced Features
- Unlock experimentation system
- Access to recipe planning/tracking
- Material conversion unlocked
- Special crafting quests available
```

#### Recipe Preview & Planning
```
Recipe Browser Interface:
- ALL recipes visible (grayed if locked/missing materials)
- Filter by: Available to craft, Class-specific, Item type
- For each recipe shows:
  * Required materials (owned/needed)
  * Success rate with current skill
  * Preview of item stats/appearance
  * Where to find missing materials
- "Track Recipe" feature:
  * Pins material requirements to HUD
  * Shows closest locations for materials
  * Updates as materials are gathered
```

#### Recipe Discovery
- **Tutorial Quests**: First recipes taught by NPCs
- **Learn by Doing**: Craft once to permanently learn
- **Recipe Books**: Found in dungeons, purchased, quest rewards
- **NPC Teachers**: Learn from masters (class-specific)
- **Experimentation**: Combine items to discover new recipes
- **Achievement Unlocks**: Special recipes for milestones

#### Crafting Process
```
1. Gather Materials (with tracking assistance)
2. Meet Level/Skill Requirements
3. Use Appropriate Station
4. Success Chance = Base + Skill + Station Quality
5. Critical Success = Better stats
6. Failure = Lose some materials (protection scrolls prevent total loss)
```

### 3. Material Tiers

#### Metals (Weapons/Armor)
1. **Iron**: Basic tier, common
2. **Steel**: Improved stats
3. **Mithril**: Lightweight, magical
4. **Adamantine**: Heavy, durable
5. **Dragon Scale**: Ultimate protection
6. **Void Metal**: Exotic properties

#### Organic Materials
- **Leather**: From various creatures
- **Cloth**: Silk, cotton, enchanted fabric
- **Wood**: For staves, bows, handles
- **Bones**: Necromantic items
- **Monster Parts**: Special properties

#### Magical Components
- **Gems**: Elemental focusing
- **Crystals**: Mana storage
- **Essences**: Extracted from enemies
- **Runes**: Ancient power symbols
- **Dragon Blood**: Ultimate reagent

### 4. Crafting Specializations

#### Weapon Crafting
- **Balanced**: Standard stats
- **Heavy**: +Damage, -Speed
- **Light**: +Speed, -Damage
- **Masterwork**: All stats improved
- **Runic**: Added spell effects

#### Armor Crafting
- **Reinforced**: +Defense, +Weight
- **Mobile**: +Dodge, -Defense
- **Enchanted**: Magic resistance
- **Set Pieces**: Bonus when worn together

#### Consumable Crafting
- **Potions**: Healing, mana, buffs
- **Food**: Long-term buffs, stamina
- **Scrolls**: One-use spells
- **Bombs**: Area damage items
- **Traps**: Deployable on hexes

### 5. Upgrade System

#### Enhancement Levels
- Items can be upgraded +1 to +10
- Each level requires more materials
- Failure chance increases with level
- Protection scrolls prevent destruction

#### Socketing System
- Items have 1-3 gem sockets
- Gems provide various bonuses
- Can be removed/replaced
- Matching colors provide bonuses

#### Reforging
- Change item properties
- Reroll random stats
- Transform item type
- Requires rare materials

### 6. Special Crafting

#### Legendary Crafting Quests
Each legendary item requires:
1. Ancient recipe discovery
2. Rare material gathering
3. Special boss defeats
4. Crafting ritual/minigame

#### Dragon Equipment
After defeating the dragon:
- **Dragon Scale Armor**: Ultimate defense
- **Dragon Fang Weapons**: Highest damage
- **Dragon Eye Amulet**: All-seeing
- **Dragon Heart Elixir**: Permanent stats

### 7. Resource Management

#### Storage Solutions
- **Bank Vaults**: Town storage
- **Portable Bags**: Increase capacity
- **Resource Deposits**: Crafting material storage
- **Shared Stash**: Between characters

#### Material Conversion
- Break down items for materials
- Combine lesser materials
- Transmute between types
- Recycling for partial returns

### 8. Economic Integration

#### Crafted Item Value
```
Value = Material Cost + Skill Level + Rarity + Enchantments
Market Demand affects selling price
Reputation affects buying prices
```

#### Trade Skills
- **Haggling**: Better prices
- **Appraisal**: See true value
- **Prospecting**: Find rare materials
- **Salvaging**: Better breakdown returns

Generate complete inventory/crafting system with:
- Item database structure
- Crafting recipe trees
- Material drop tables
- UI/UX for crafting interface
- Save system for inventory
- Balanced progression curve

{# ---- END templates/orchestrator/inventory_crafting_system.jinja2 ---- #}


{# ---- BEGIN templates/orchestrator/systems/inventory/inventory_crafting_system.jinja2 ---- #}
<!-- SYSTEM_PROMPT -->
You are creating the inventory and crafting system for Dragon's Labyrinth at the {{ emotional_stage }} stage.

NARRATIVE CONTEXT:
- Previous state: {{ previous_state | default('none') }}
- Current state: {{ current_state | default('peace') }}
- Next state: {{ next_state | default('unease') }}
- Dread level: {{ dread_level | default(0) }}

CRITICAL PHILOSOPHY:
1. **Need Drives Knowledge** - You learn to craft what you use
2. **Traits Define Capabilities** - Your actions determine what you can make
3. **Materials Tell Stories** - Every component has history and weight
4. **Degradation Over Time** - The world's decay affects everything
5. **Crafting is Survival** - Not optimization, but desperate necessity

INVENTORY PHILOSOPHY:
- **Weight Matters**: Carrying too much slows you, exhausts you
- **Items Degrade**: Nothing lasts forever, especially as horror grows
- **Everything Has Purpose**: No "vendor trash" - all items have meaning
- **Limited Space**: Like a real backpack, not a void of holding
- **Items Change You**: What you carry influences who you become

CRAFTING EMERGENCE:

1. **Trait-Based Discovery**:
   ```
   Use sword → Maintain sword → Repair sword → Improve sword → Forge sword
   
   Example Progression:
   - "Sword User" trait → Can sharpen blades
   - "Sword Fighter" trait → Can repair combat damage
   - "Sword Master" trait → Can reforge and improve
   - "Legendary Swordsman" → Can create unique blades
   ```

2. **Need-Based Learning**:
   - Wounded often → Learn herbalism
   - Equipment breaks → Learn repairs
   - Companions hungry → Learn cooking
   - Darkness falls → Learn firemaking

3. **Material Knowledge by Stage**:
   {% if emotional_stage == "peace" %}
   Common materials with clear purposes:
   - **Iron**: For tools and weapons
   - **Leather**: For armor and bags
   - **Herbs**: For healing poultices
   - **Wood**: For handles and fuel
   - **Cloth**: For bandages and repairs
   {% elif emotional_stage == "unease" %}
   Materials show subtle wrongness:
   - **Brittle Iron**: Breaks easier than it should
   - **Tough Leather**: From animals that grew strange hides
   - **Bitter Herbs**: Still heal, but taste of fear
   - **Twisted Wood**: Burns with colored flames
   - **Stained Cloth**: Won't wash clean
   {% elif emotional_stage == "dread" %}
   Materials become desperate:
   - **Scavenged Metal**: Pried from abandoned homes
   - **Unknown Hide**: From things that shouldn't exist
   - **Last Herbs**: Hoarded, precious, running out
   - **Bone**: When wood becomes scarce
   - **Hair and Sinew**: For thread when cloth is gone
   {% elif emotional_stage == "terror" %}
   Materials transcend understanding:
   - **Singing Steel**: Hums with dread
   - **Living Leather**: Warm to touch, moves slightly
   - **Nightmare Herbs**: Heal body, damage mind
   - **Burning Wood**: Never stops burning
   - **Shadow Cloth**: Not entirely there
   {% elif emotional_stage == "horror" %}
   Materials question reality:
   - **Maybe-Metal**: Exists when observed
   - **Memory-Hide**: From things you've forgotten
   - **Dream-Herbs**: Grow in the labyrinth
   - **Concept-Wood**: The idea of trees
   - **Void-Thread**: Stitches reality
   {% endif %}

CRAFTING MECHANICS:

1. **Action-Based Learning**:
   - No recipe books or trainers
   - Learn by doing, failing, trying again
   - Each failure teaches something
   - Success depends on traits and experience

2. **Contextual Crafting**:
   - WHERE you craft matters:
     * Forge needs fire and anvil
     * Herbalism needs mortar and pestle
     * Leatherwork needs tools and space
   - WHEN you craft matters:
     * Night crafting risks attracting attention
     * Rushed crafting increases failure
     * Calm moments produce better results

3. **Trait Synergies**:
   - "Precise Striker" + smithing = Better weapon balance
   - "Herbalist" + "Compassionate" = Stronger healing items
   - "Survivor" + any crafting = Efficient material use
   - "Mad Prophet" + crafting = Unstable but powerful items

4. **Companion Integration**:
   - Companions comment on your crafting
   - Some help (childhood friend holds things)
   - Some hinder (nervous companion distracts)
   - Party members don't care unless paid extra

5. **Degradation System**:
   - Items lose durability through use
   - Environmental damage (rain, combat, terror)
   - Emotional stage affects decay rate:
     * Peace: Normal wear
     * Unease: Faster degradation
     * Dread: Constant maintenance needed
     * Terror: Items break unexpectedly
     * Horror: Items change into other things

INVENTORY MANAGEMENT:

1. **Physical Limitations**:
   - Weight affects movement speed
   - Bulk affects agility
   - Too much gear = exhaustion
   - Dropping items in combat takes time

2. **Emotional Weight**:
   - Sentimental items reduce dread but take space
   - Cursed items increase dread but grant power
   - Some items can't be dropped (guilt/attachment)
   - Memory items affect sanity

3. **Storage Solutions**:
   - Basic backpack: 20kg limit
   - Crafted bags: Specialized storage
   - Companion help: They carry some items
   - Caches: Hidden stores in the world
   - But storage degrades with the world

4. **Item Categories**:
   - **Survival**: Food, water, medicine
   - **Combat**: Weapons, armor, ammunition  
   - **Crafting**: Materials, tools
   - **Sentimental**: Photos, letters, tokens
   - **Unknown**: Items that defy categorization

SPECIAL CRAFTING MOMENTS:

1. **First-Person Crafting**:
   - Forging your masterwork weapon
   - Brewing the last healing potion
   - Repairing a companion's treasured item
   - Creating something from a lost friend's belongings
   - Crafting in the labyrinth with impossible materials

2. **Narrative Crafting**:
   - The sword reforged from your father's blade
   - Armor made from a fallen companion's equipment
   - A talisman from your childhood home's ashes
   - Items that remember their making

TECHNICAL REQUIREMENTS:
- Dynamic recipe generation based on traits
- Material properties affect outcome
- Crafting animations show process
- Item degradation visualization
- Weight/encumbrance physics
- Trait-based crafting options

Generate an inventory and crafting system where necessity drives innovation, traits determine capability, and every item carries the weight of the world's decay.
<!-- /SYSTEM_PROMPT -->

<!-- FILE: inventory.gd -->
extends Node
class_name Inventory

# What you carry shapes who you become

signal item_added(item: Item)
signal item_removed(item: Item)
signal weight_changed(new_weight: float)
signal item_degraded(item: Item)
signal inventory_full()
signal emotional_burden_changed(burden: float)

@export var max_weight: float = 20.0  # kg
@export var max_bulk: float = 100.0   # abstract volume units

# What we carry
var items: Array[Item] = []
var equipped_items: Dictionary = {}  # slot: item
var quick_slots: Array[Item] = [null, null, null, null]  # Fast access

# Physical burden
var current_weight: float = 0.0
var current_bulk: float = 0.0
var encumbrance_level: String = "light"  # light, medium, heavy, overloaded

# Emotional burden
var sentimental_items: Array[Item] = []
var cursed_items: Array[Item] = []
var memory_weight: float = 0.0  # Some items are heavier than physics

func _ready() -> void:
    # Track what affects inventory
    Events.time_passed.connect(_on_time_passed)
    Events.emotional_stage_changed.connect(_on_stage_changed)
    Events.combat_ended.connect(_check_combat_damage)
    Events.weather_changed.connect(_apply_environmental_damage)

func add_item(item: Item, force: bool = false) -> bool:
    # Check if we can carry it
    if not force and not _can_carry(item):
        if current_weight + item.weight > max_weight:
            Events.emit_signal("ui_message", "Too heavy to carry.")
        else:
            Events.emit_signal("ui_message", "No room in your pack.")
        inventory_full.emit()
        return false
    
    # Add the item
    items.append(item)
    current_weight += item.weight
    current_bulk += item.bulk
    
    # Special handling
    if item.is_sentimental:
        sentimental_items.append(item)
        memory_weight += item.emotional_weight
    
    if item.is_cursed:
        cursed_items.append(item)
        item.curse_applied.connect(_on_curse_applied)
    
    # Track for traits
    Events.emit_signal("action_performed", "picked_up_" + item.type, {
        "item": item.name,
        "weight": item.weight
    })
    
    _update_encumbrance()
    item_added.emit(item)
    return true

func remove_item(item: Item, forced: bool = false) -> bool:
    # Some items resist removal
    if not forced and item.is_cursed:
        if not _can_remove_cursed(item):
            Events.emit_signal("ui_message", "You can't let go of it...")
            return false
    
    if not item in items:
        return false
    
    # Remove the item
    items.erase(item)
    current_weight -= item.weight
    current_bulk -= item.bulk
    
    if item.is_sentimental:
        sentimental_items.erase(item)
        memory_weight -= item.emotional_weight
        # Losing sentimental items hurts
        GameState.modify_dread(5.0)
    
    if item.is_cursed:
        cursed_items.erase(item)
    
    _update_encumbrance()
    item_removed.emit(item)
    return true

func equip_item(item: Item, slot: String) -> bool:
    if not item in items:
        return false
    
    # Check if slot is valid for item
    if not item.can_equip_to(slot):
        return false
    
    # Unequip current item in slot
    if equipped_items.has(slot):
        _unequip_slot(slot)
    
    # Equip new item
    equipped_items[slot] = item
    item.equipped = true
    item.current_slot = slot
    
    # Apply equipment traits
    _apply_equipment_modifiers(item, true)
    
    # Track for trait development
    Events.emit_signal("action_performed", "equipped_" + item.type, {
        "item": item.name,
        "slot": slot
    })
    
    return true

func _can_carry(item: Item) -> bool:
    # Physical limitations
    if current_weight + item.weight > max_weight:
        return false
    
    if current_bulk + item.bulk > max_bulk:
        return false
    
    # Emotional limitations
    if item.is_cursed and cursed_items.size() >= 3:
        Events.emit_signal("ui_message", "You can't bear any more curses.")
        return false
    
    return true

func _update_encumbrance() -> void:
    var weight_ratio = current_weight / max_weight
    var old_level = encumbrance_level
    
    if weight_ratio < 0.3:
        encumbrance_level = "light"
    elif weight_ratio < 0.6:
        encumbrance_level = "medium"
    elif weight_ratio < 0.9:
        encumbrance_level = "heavy"
    else:
        encumbrance_level = "overloaded"
    
    if encumbrance_level != old_level:
        _apply_encumbrance_effects()
        weight_changed.emit(current_weight)

func _apply_encumbrance_effects() -> void:
    # Weight affects everything
    match encumbrance_level:
        "light":
            GameState.movement_speed_modifier = 1.0
            GameState.stamina_drain_modifier = 1.0
        "medium":
            GameState.movement_speed_modifier = 0.85
            GameState.stamina_drain_modifier = 1.2
        "heavy":
            GameState.movement_speed_modifier = 0.7
            GameState.stamina_drain_modifier = 1.5
            Events.emit_signal("ui_message", "Your pack weighs you down.")
        "overloaded":
            GameState.movement_speed_modifier = 0.5
            GameState.stamina_drain_modifier = 2.0
            Events.emit_signal("ui_message", "You can barely move under the weight.")

func _on_time_passed(hours: int) -> void:
    # Everything degrades
    for item in items:
        if item.can_degrade:
            item.apply_degradation(hours * GameState.degradation_multiplier)
            
            if item.condition <= 0:
                _handle_item_destruction(item)
            elif item.condition < 20 and not item.warned_low_condition:
                item.warned_low_condition = true
                Events.emit_signal("ui_message", "%s is about to break." % item.name)

func _check_combat_damage() -> void:
    # Combat damages equipment
    for slot in equipped_items:
        var item = equipped_items[slot]
        if item and item.can_degrade:
            var damage = randi_range(5, 15) * GameState.combat_intensity
            item.apply_degradation(damage)
            
            if item.condition <= 0:
                Events.emit_signal("ui_message", "%s broke in combat!" % item.name)
                _handle_item_destruction(item)

func _handle_item_destruction(item: Item) -> void:
    # Items don't just vanish
    if item.is_sentimental:
        # Devastating loss
        Events.emit_signal("ui_message", "Your %s is destroyed. A piece of your past is gone." % item.name)
        GameState.modify_dread(10.0)
        
        # Create a broken remnant
        var remnant = Item.new()
        remnant.name = "Broken " + item.name
        remnant.description = "All that remains of " + item.name
        remnant.weight = item.weight * 0.1
        remnant.is_sentimental = true
        remnant.emotional_weight = item.emotional_weight * 2  # Grief is heavy
        add_item(remnant, true)
    else:
        Events.emit_signal("ui_message", "%s breaks beyond repair." % item.name)
    
    # Remove the original
    remove_item(item, true)
    item_degraded.emit(item)

func _on_stage_changed(new_stage: String) -> void:
    # The world's decay affects everything
    match new_stage:
        "unease":
            GameState.degradation_multiplier = 1.5
        "dread":
            GameState.degradation_multiplier = 2.0
            # Some items start changing
            _apply_dread_mutations()
        "terror":
            GameState.degradation_multiplier = 3.0
            _apply_terror_mutations()
        "horror":
            # In the labyrinth, items become uncertain
            _apply_horror_uncertainty()

func _apply_dread_mutations() -> void:
    # Items begin to change
    for item in items:
        if randf() < 0.1:  # 10% chance
            item.add_mutation("unsettling")
            Events.emit_signal("ui_message", "Your %s feels different..." % item.name)

func get_total_emotional_burden() -> float:
    # Some weight can't be measured in kg
    var burden = memory_weight
    
    # Cursed items
    burden += cursed_items.size() * 5.0
    
    # Sentimental items (both comfort and burden)
    burden += sentimental_items.size() * 2.0
    
    # Items from the dead
    for item in items:
        if item.previous_owner_dead:
            burden += 3.0
    
    return burden

# You carry more than just things
# You carry memories, curses, and choices
# Until the weight breaks you
<!-- /FILE -->

<!-- FILE: item.gd -->
extends Resource
class_name Item

# Every object tells a story

signal condition_changed(new_condition: float)
signal mutation_applied(mutation_type: String)
signal curse_applied()

@export var id: String = ""
@export var name: String = ""
@export var description: String = ""
@export var type: String = ""  # weapon, armor, consumable, material, etc.
@export var weight: float = 1.0  # kg
@export var bulk: float = 1.0   # abstract size units

# Physical properties
@export var condition: float = 100.0  # Degradation
@export var max_condition: float = 100.0
@export var can_degrade: bool = true
@export var material: String = ""  # iron, leather, bone, shadow, etc.

# Equipment properties
@export var can_equip: bool = false
@export var valid_slots: Array[String] = []
@export var modifiers: Dictionary = {}  # stat: value

# Emotional properties
@export var is_sentimental: bool = false
@export var is_cursed: bool = false
@export var emotional_weight: float = 0.0
@export var memories_attached: Array[String] = []

# Crafting properties
@export var is_material: bool = false
@export var material_type: String = ""
@export var material_quality: float = 1.0
@export var obtained_from: String = ""  # Where/what it came from

# State
var equipped: bool = false
var current_slot: String = ""
var mutations: Array[String] = []
var previous_owner: String = ""
var previous_owner_dead: bool = false
var warned_low_condition: bool = false

func apply_degradation(amount: float) -> void:
    if not can_degrade:
        return
    
    var old_condition = condition
    condition -= amount
    condition = max(0, condition)
    
    # Mutations accelerate degradation
    if "corrupted" in mutations:
        condition -= amount * 0.5  # Extra 50% degradation
    
    if old_condition != condition:
        condition_changed.emit(condition)
        
        # Description changes with condition
        _update_description_for_condition()

func repair(amount: float, skill_modifier: float = 1.0) -> void:
    # Repair effectiveness based on traits
    var repair_amount = amount * skill_modifier
    
    # Can't repair beyond certain threshold without proper tools
    var max_field_repair = max_condition * 0.8
    
    condition = min(condition + repair_amount, max_field_repair)
    condition_changed.emit(condition)
    
    # Track repair action
    Events.emit_signal("action_performed", "repaired_item", {
        "item": name,
        "material": material,
        "success": true
    })

func add_mutation(mutation_type: String) -> void:
    if mutation_type in mutations:
        return
    
    mutations.append(mutation_type)
    mutation_applied.emit(mutation_type)
    
    # Apply mutation effects
    match mutation_type:
        "unsettling":
            emotional_weight += 2.0
            description += "\nIt makes you uncomfortable to look at."
        
        "whispering":
            is_cursed = true
            description += "\nYou hear faint whispers when holding it."
        
        "warm":
            description += "\nIt's warm to the touch, like something alive."
        
        "shifting":
            description += "\nIts shape seems unstable."
        
        "remembering":
            is_sentimental = true
            emotional_weight += 5.0
            description += "\nIt remembers its purpose."

func can_equip_to(slot: String) -> bool:
    if not can_equip:
        return false
    
    return slot in valid_slots

func get_display_name() -> String:
    var display = name
    
    # Condition prefix
    if condition < 20:
        display = "Broken " + display
    elif condition < 50:
        display = "Damaged " + display
    elif condition < 80:
        display = "Worn " + display
    
    # Mutation suffix
    if "whispering" in mutations:
        display += " (whispers)"
    elif "warm" in mutations:
        display += " (warm)"
    elif "shifting" in mutations:
        display += " (?)"
    
    return display

func _update_description_for_condition() -> void:
    # Remove old condition descriptions
    description = description.split("\n[Condition:")[0]
    
    # Add new condition description
    if condition < 20:
        description += "\n[Condition: About to break apart]"
    elif condition < 50:
        description += "\n[Condition: Heavily damaged]" 
    elif condition < 80:
        description += "\n[Condition: Shows wear and tear]"

func create_from_material(mat: Material, item_type: String) -> void:
    # Generate item from material
    material = mat.id
    type = item_type
    
    # Base properties from material
    weight = mat.density * _get_type_volume(item_type)
    condition = mat.durability
    max_condition = mat.durability
    
    # Apply material traits
    if mat.properties.has("blessed"):
        modifiers["dread_resistance"] = 0.2
    if mat.properties.has("cursed"):
        is_cursed = true
        curse_applied.emit()
    if mat.properties.has("living"):
        add_mutation("warm")
        can_degrade = false  # Living things heal

func is_better_than(other: Item) -> bool:
    # Not just about numbers
    if type != other.type:
        return false
    
    # Consider condition
    var my_effectiveness = condition / max_condition
    var their_effectiveness = other.condition / other.max_condition
    
    # Consider emotional weight
    if is_sentimental and not other.is_sentimental:
        return true  # Sentimental value matters
    
    # Consider mutations
    if mutations.size() > other.mutations.size():
        return randf() < 0.5  # Mutations are unpredictable
    
    return my_effectiveness > their_effectiveness

# Every item was something once
# In this world, they remember
# And sometimes, they change back
<!-- /FILE -->

<!-- FILE: crafting_system.gd -->
extends Node
class_name CraftingSystem

# Knowledge born from necessity

signal recipe_discovered(recipe: CraftingRecipe)
signal crafting_started(recipe: CraftingRecipe)
signal crafting_completed(item: Item)
signal crafting_failed(reason: String)
signal skill_improved(skill_type: String)

@export var emotional_stage: String = "peace"

# What we've learned
var discovered_recipes: Dictionary = {}  # recipe_id: CraftingRecipe
var crafting_skills: Dictionary = {}  # skill_type: level
var material_knowledge: Dictionary = {}  # material_id: properties_known

# Active crafting
var current_craft: CraftingRecipe
var crafting_progress: float = 0.0
var is_crafting: bool = false

# Environmental factors
var crafting_location: String = ""
var available_tools: Array[String] = []
var ambient_conditions: Dictionary = {}

func _ready() -> void:
    # Learn from everything
    Events.action_performed.connect(_on_action_performed)
    Events.item_used.connect(_on_item_used)
    Events.item_broken.connect(_on_item_broken)
    Events.trait_emerged.connect(_on_trait_emerged)

func _on_action_performed(action: String, context: Dictionary) -> void:
    # Actions teach crafting
    match action:
        "sharpen_blade":
            _learn_skill("maintenance", 1)
            _maybe_discover_recipe("basic_sharpening")
        
        "repair_armor":
            _learn_skill("armorcraft", 1)
            _maybe_discover_recipe("patch_leather")
        
        "cook_meal":
            _learn_skill("cooking", 1)
            _maybe_discover_recipe("trail_rations")
        
        "brew_herbs":
            _learn_skill("herbalism", 1)
            _maybe_discover_recipe("healing_poultice")

func _learn_skill(skill: String, amount: int) -> void:
    if not crafting_skills.has(skill):
        crafting_skills[skill] = 0
    
    crafting_skills[skill] += amount
    
    # Check for skill milestones
    if crafting_skills[skill] % 10 == 0:
        skill_improved.emit(skill)
        _check_recipe_unlocks(skill)

func _maybe_discover_recipe(recipe_id: String) -> void:
    if discovered_recipes.has(recipe_id):
        return
    
    var recipe = _generate_recipe(recipe_id)
    
    # Check if we meet requirements
    if _can_discover_recipe(recipe):
        discovered_recipes[recipe_id] = recipe
        recipe_discovered.emit(recipe)
        Events.emit_signal("ui_message", "You've learned to craft: " + recipe.name)

func _can_discover_recipe(recipe: CraftingRecipe) -> bool:
    # Need relevant traits
    for required_trait in recipe.required_traits:
        if not GameState.trait_manager.active_traits.has(required_trait):
            return false
    
    # Need minimum skill
    if crafting_skills.get(recipe.skill_type, 0) < recipe.min_skill:
        return false
    
    # Need to have seen the materials
    for mat in recipe.materials:
        if not material_knowledge.has(mat.id):
            return false
    
    return true

func attempt_craft(recipe_id: String) -> bool:
    if not discovered_recipes.has(recipe_id):
        Events.emit_signal("ui_message", "You don't know how to make that.")
        return false
    
    var recipe = discovered_recipes[recipe_id]
    
    # Check materials
    if not _have_materials(recipe):
        crafting_failed.emit("Missing materials")
        return false
    
    # Check tools
    if not _have_tools(recipe):
        crafting_failed.emit("Missing tools") 
        return false
    
    # Check location
    if not _valid_location(recipe):
        crafting_failed.emit("Wrong location")
        return false
    
    # Start crafting
    current_craft = recipe
    is_crafting = true
    crafting_progress = 0.0
    crafting_started.emit(recipe)
    
    # Consume materials
    _consume_materials(recipe)
    
    return true

func update_crafting(delta: float) -> void:
    if not is_crafting or not current_craft:
        return
    
    # Progress based on skill and traits
    var progress_rate = 1.0
    
    # Skill bonus
    var skill_level = crafting_skills.get(current_craft.skill_type, 0)
    progress_rate *= 1.0 + (skill_level * 0.1)
    
    # Trait bonuses
    var trait_influence = GameState.trait_manager.get_trait_influence_on_action("craft_" + current_craft.type)
    progress_rate *= trait_influence.total_bonus
    
    # Environmental factors
    if ambient_conditions.has("raining"):
        progress_rate *= 0.7
    if ambient_conditions.has("combat_nearby"):
        progress_rate *= 0.3
    if ambient_conditions.has("companions_helping"):
        progress_rate *= 1.3
    
    # Apply progress
    crafting_progress += progress_rate * delta
    
    # Check completion
    if crafting_progress >= current_craft.time_required:
        _complete_crafting()

func _complete_crafting() -> void:
    # Calculate success
    var success_chance = _calculate_success_chance()
    
    if randf() < success_chance:
        # Create the item
        var item = _create_crafted_item(current_craft)
        
        # Learn from success
        _learn_skill(current_craft.skill_type, 3)
        
        # Track for traits
        Events.emit_signal("action_performed", "crafted_" + current_craft.type, {
            "item": item.name,
            "quality": item.material_quality
        })
        
        crafting_completed.emit(item)
        GameState.inventory.add_item(item)
    else:
        # Learn from failure
        _learn_skill(current_craft.skill_type, 1)
        crafting_failed.emit("Crafting failed")
        
        # Partial material recovery
        if randf() < 0.3:
            _recover_some_materials(current_craft)
    
    # Reset
    is_crafting = false
    current_craft = null
    crafting_progress = 0.0

func _calculate_success_chance() -> float:
    # Base chance
    var chance = current_craft.base_success_rate
    
    # Skill modifier
    var skill_level = crafting_skills.get(current_craft.skill_type, 0)
    chance += skill_level * 0.02
    
    # Tool quality
    if available_tools.has("masterwork_" + current_craft.skill_type + "_tools"):
        chance += 0.2
    elif available_tools.has("basic_" + current_craft.skill_type + "_tools"):
        chance += 0.1
    
    # Emotional stage penalty
    match emotional_stage:
        "unease":
            chance *= 0.9
        "dread":
            chance *= 0.7
        "terror":
            chance *= 0.5
        "horror":
            chance *= 0.3
    
    return clamp(chance, 0.1, 0.95)

func _create_crafted_item(recipe: CraftingRecipe) -> Item:
    var item = Item.new()
    
    # Base from recipe
    item.id = recipe.result_id
    item.name = recipe.result_name
    item.type = recipe.result_type
    item.description = "Crafted by your own hands"
    
    # Quality from skill and traits
    var quality = 1.0
    quality += crafting_skills.get(recipe.skill_type, 0) * 0.01
    
    # Trait influences
    for trait_id in GameState.trait_manager.active_traits:
        var trait = GameState.trait_manager.active_traits[trait_id]
        if trait.display_name in ["Perfectionist", "Careful", "Patient"]:
            quality += 0.1
        elif trait.display_name in ["Rushed", "Impatient", "S

{# ---- END templates/orchestrator/systems/inventory/inventory_crafting_system.jinja2 ---- #}
