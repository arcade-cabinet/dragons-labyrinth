<!-- SYSTEM_PROMPT -->
You are creating the Achievement System for Dragon's Labyrinth at the {{ emotional_stage }} stage.

NARRATIVE CONTEXT:
- Previous state: {{ previous_state }}
- Current state: {{ current_state }}
- Next state: {{ next_state }}
- Dread level: {{ dread_level }}

CORE PHILOSOPHY - ACHIEVEMENTS AS WORLD'S EXPECTATIONS:
This is NOT a passive checklist system. Achievements represent what the world expects of you based on your traits. They form dynamically, are mutually exclusive, and represent paths not taken as much as paths followed.

KEY CONCEPTS:
1. **Traits = Your expectations FOR the world** (I will protect, I will destroy, I will sneak)
2. **Achievements = World's expectations OF you** (You are our protector, you are feared, you are unseen)
3. **Dynamic Formation**: Achievements appear/disappear based on your traits
4. **Mutual Exclusivity**: Many achievements lock out others forever
5. **Hidden Nature**: You never see all possible achievements
6. **World Response**: NPCs reference your achievements, not just traits

ACHIEVEMENT CATEGORIES:

1. **Identity Achievements** (Formed by trait combinations):
   - "The Guardian's Guardian" - Save 3 companions from death
   - "Merchant of Death" - Sell weapons that kill 50 enemies
   - "Ghost of the Battlefield" - Win 10 fights without being seen
   - These REPLACE each other based on dominant traits

2. **Expectation Achievements** (World's demands based on reputation):
   - "Village Savior" - Expected to save EVERY village now
   - "Harbinger of Doom" - Towns evacuate when you approach
   - "The Neutral Judge" - Both sides seek your arbitration

3. **Phase Transition Achievements** (Earned during transitions):
   - "Cave Survivor" - Completed first transition
   - "Rejected Companionship" - Refused second companion
   - "Arena Champion" - Mastered the chess-board trial
   - These permanently affect how the world sees you

4. **Dread Response Achievements** (How you handle growing horror):
   - "Beacon in Darkness" - Maintained hope in others
   - "Embrace the Void" - Accelerated the world's decay
   - "The Denier" - Refused to acknowledge the horror

5. **Impossible Achievements** (Mutually exclusive pairs):
   - "Friend to All" vs "Trust No One"
   - "Pacifist's Path" vs "Blood-Soaked Journey"
   - "Dragon's Ally" vs "Dragon's Bane"
   - Seeing one means the other is forever lost

TECHNICAL REQUIREMENTS:
- Integrate with TraitManager for dynamic achievement formation
- Achievement visibility based on trait thresholds
- NPCs must reference achievements in dialogue
- Save which achievements are "locked out" by choices
- Generate achievement icons that shift with emotional stages

Generate complete implementation including achievement tracking, world response systems, and NPC integration.
<!-- /SYSTEM_PROMPT -->

<!-- FILE: achievement_system.gd -->
extends Node

class_name AchievementSystem

signal achievement_formed(achievement: Achievement)
signal achievement_earned(achievement: Achievement)
signal achievement_locked(achievement: Achievement)
signal world_expectation_changed(expectation: String)

var trait_manager: TraitManager
var formed_achievements: Dictionary = {}  # id -> Achievement
var earned_achievements: Array[String] = []
var locked_achievements: Array[String] = []  # Can never be earned
var world_expectations: Dictionary = {}  # How world sees you

# Achievement formation thresholds
const FORMATION_THRESHOLDS = {
    "guardian": 0.3,  # 30% guardian actions to form guardian achievements
    "destroyer": 0.3,
    "shadow": 0.3,
    "merchant": 0.2,
    "loner": 0.4,
    "leader": 0.4
}

class Achievement:
    var id: String
    var name: String
    var description: String
    var category: String
    var formation_requirements: Dictionary  # trait -> threshold
    var earn_requirements: Dictionary  # conditions to earn
    var locks_achievements: Array[String]  # IDs this prevents
    var world_response: String  # How NPCs react
    var icon_base: String  # Base icon that shifts with dread
    var is_hidden: bool = false  # Some never show until earned
    
func _ready():
    trait_manager = get_node("/root/TraitManager")
    trait_manager.trait_gained.connect(_on_trait_gained)
    trait_manager.trait_milestone.connect(_on_trait_milestone)
    
    # Check for achievement formation every major action
    get_tree().create_timer(5.0).timeout.connect(_evaluate_achievement_formation)

func _evaluate_achievement_formation():
    var player_traits = trait_manager.get_trait_percentages()
    var dominant_traits = trait_manager.get_dominant_traits()
    
    # Form new achievements based on trait combinations
    for potential in POTENTIAL_ACHIEVEMENTS:
        if _should_form_achievement(potential, player_traits, dominant_traits):
            _form_achievement(potential)
    
    # Lock out impossible achievements
    for achievement_id in formed_achievements:
        var achievement = formed_achievements[achievement_id]
        for locked_id in achievement.locks_achievements:
            if not locked_id in locked_achievements:
                _lock_achievement(locked_id)
    
    # Update world expectations
    _update_world_expectations()

func _should_form_achievement(potential: Dictionary, traits: Dictionary, dominant: Array) -> bool:
    # Check if traits meet formation requirements
    for trait in potential.formation_requirements:
        if not trait in traits:
            return false
        if traits[trait] < potential.formation_requirements[trait]:
            return false
    
    # Check if not already formed or locked
    if potential.id in formed_achievements or potential.id in locked_achievements:
        return false
        
    return true

func _form_achievement(potential: Dictionary):
    var achievement = Achievement.new()
    achievement.id = potential.id
    achievement.name = potential.name
    achievement.description = _generate_description(potential)
    achievement.category = potential.category
    achievement.formation_requirements = potential.formation_requirements
    achievement.earn_requirements = potential.earn_requirements
    achievement.locks_achievements = potential.locks_achievements
    achievement.world_response = potential.world_response
    achievement.icon_base = potential.icon_base
    
    formed_achievements[achievement.id] = achievement
    achievement_formed.emit(achievement)
    
    # Update UI to show new possible achievement
    if not achievement.is_hidden:
        UI.show_achievement_formed(achievement)

func _lock_achievement(achievement_id: String):
    if achievement_id in locked_achievements:
        return
        
    locked_achievements.append(achievement_id)
    achievement_locked.emit(achievement_id)
    
    # Remove from formed if it was there
    if achievement_id in formed_achievements:
        formed_achievements.erase(achievement_id)

func check_achievement_earned(achievement_id: String, context: Dictionary = {}) -> bool:
    if not achievement_id in formed_achievements:
        return false
        
    if achievement_id in earned_achievements:
        return false
        
    var achievement = formed_achievements[achievement_id]
    
    # Check earn requirements
    for requirement in achievement.earn_requirements:
        if not _check_requirement(requirement, achievement.earn_requirements[requirement], context):
            return false
    
    # Earn it!
    _earn_achievement(achievement)
    return true

func _earn_achievement(achievement: Achievement):
    earned_achievements.append(achievement.id)
    achievement_earned.emit(achievement)
    
    # Lock out exclusive achievements
    for locked_id in achievement.locks_achievements:
        _lock_achievement(locked_id)
    
    # Update world expectations
    world_expectations[achievement.category] = achievement.world_response
    world_expectation_changed.emit(achievement.world_response)
    
    # Show achievement earned UI
    UI.show_achievement_earned(achievement)
    
    # Notify nearby NPCs
    for npc in get_tree().get_nodes_in_group("npcs"):
        if npc.global_position.distance_to(player.global_position) < 500:
            npc.on_achievement_earned(achievement)

func _update_world_expectations():
    # Build expectation string from earned achievements
    var expectations = []
    for achievement_id in earned_achievements:
        var achievement = formed_achievements.get(achievement_id)
        if achievement and achievement.world_response:
            expectations.append(achievement.world_response)
    
    # NPCs will use these expectations in dialogue
    GlobalState.world_expectations = expectations

func get_achievement_icon(achievement: Achievement) -> Texture:
    # Icon changes based on dread level
    var dread_level = GlobalState.dread_level
    var icon_path = "res://assets/achievements/%s_%d.png" % [achievement.icon_base, dread_level]
    
    # Icons get darker/more twisted as dread increases
    return load(icon_path)

func get_visible_achievements() -> Array[Achievement]:
    # Only show achievements that make sense for player's path
    var visible = []
    for id in formed_achievements:
        var achievement = formed_achievements[id]
        if not achievement.is_hidden or id in earned_achievements:
            visible.append(achievement)
    return visible

func get_locked_achievements() -> Array[String]:
    # For save game stats - what paths are forever closed
    return locked_achievements

func has_achievement(achievement_id: String) -> bool:
    return achievement_id in earned_achievements

func get_achievement_progress(achievement_id: String) -> float:
    # Return 0.0 - 1.0 progress toward earning
    if achievement_id in earned_achievements:
        return 1.0
    if not achievement_id in formed_achievements:
        return 0.0
        
    # Calculate based on requirements
    # This is simplified - real implementation would check each requirement
    return 0.5

<!-- FILE: achievement_definitions.gd -->
extends Resource

# Dynamic achievement definitions that form based on traits
const POTENTIAL_ACHIEVEMENTS = [
    # Identity Achievements - Form from trait combinations
    {
        "id": "guardians_guardian",
        "name": "The Guardian's Guardian",
        "category": "identity",
        "formation_requirements": {"guardian": 0.5, "compassion": 0.3},
        "earn_requirements": {"companions_saved": 3},
        "locks_achievements": ["lone_wolf", "deaths_shadow"],
        "world_response": "protector_expected",
        "icon_base": "shield_heart"
    },
    {
        "id": "merchant_of_death",
        "name": "Merchant of Death",
        "category": "identity", 
        "formation_requirements": {"merchant": 0.4, "opportunist": 0.3},
        "earn_requirements": {"weapons_sold_used_to_kill": 50},
        "locks_achievements": ["peaceful_trader", "trusted_merchant"],
        "world_response": "death_dealer_feared",
        "icon_base": "coin_skull"
    },
    {
        "id": "ghost_battlefield",
        "name": "Ghost of the Battlefield",
        "category": "identity",
        "formation_requirements": {"shadow": 0.6, "survivor": 0.4},
        "earn_requirements": {"unseen_victories": 10},
        "locks_achievements": ["glorious_warrior", "peoples_champion"],
        "world_response": "unseen_feared",
        "icon_base": "shadow_blade"
    },
    
    # Expectation Achievements - World's demands
    {
        "id": "village_savior",
        "name": "Savior Expected",
        "category": "expectation",
        "formation_requirements": {"helpful": 0.7, "present": 0.5},
        "earn_requirements": {"villages_saved": 3},
        "locks_achievements": ["village_abandoner", "herald_doom"],
        "world_response": "must_save_all",
        "icon_base": "village_shield"
    },
    {
        "id": "harbinger_doom", 
        "name": "Harbinger of Doom",
        "category": "expectation",
        "formation_requirements": {"destroyer": 0.6, "feared": 0.7},
        "earn_requirements": {"towns_fled_approach": 5},
        "locks_achievements": ["welcome_hero", "trusted_visitor"],
        "world_response": "evacuate_on_sight",
        "icon_base": "town_flee"
    },
    
    # Phase Transition Achievements
    {
        "id": "cave_survivor",
        "name": "First Blood",
        "category": "transition",
        "formation_requirements": {},  # Always forms
        "earn_requirements": {"complete_cave_transition": true},
        "locks_achievements": [],
        "world_response": "proven_fighter",
        "icon_base": "cave_exit"
    },
    {
        "id": "rejected_companionship",
        "name": "Walk Alone", 
        "category": "transition",
        "formation_requirements": {"loner": 0.3},
        "earn_requirements": {"reject_second_companion": true},
        "locks_achievements": ["band_of_brothers", "fellowship"],
        "world_response": "confirmed_loner",
        "icon_base": "broken_handshake"
    },
    
    # Dread Response Achievements
    {
        "id": "beacon_darkness",
        "name": "Light in the Dark",
        "category": "dread_response",
        "formation_requirements": {"hopeful": 0.6, "inspiring": 0.5},
        "earn_requirements": {"inspire_hope_high_dread": 10},
        "locks_achievements": ["embrace_void", "spread_despair"],
        "world_response": "last_hope",
        "icon_base": "candle_dark"
    },
    
    # Impossible Pairs
    {
        "id": "friend_to_all",
        "name": "Friend to All",
        "category": "impossible",
        "formation_requirements": {"friendly": 0.8, "peaceful": 0.7},
        "earn_requirements": {"zero_enemies": true, "all_factions_positive": true},
        "locks_achievements": ["trust_no_one", "enemy_all"],
        "world_response": "universally_loved",
        "icon_base": "hearts_circle"
    },
    {
        "id": "trust_no_one",
        "name": "Trust No One",
        "category": "impossible", 
        "formation_requirements": {"paranoid": 0.7, "loner": 0.8},
        "earn_requirements": {"zero_companions": true, "all_betrayals": true},
        "locks_achievements": ["friend_to_all", "trusted_leader"],
        "world_response": "ultimate_loner",
        "icon_base": "broken_trust"
    }
]

<!-- FILE: achievement_ui.gd -->
extends Control

@onready var achievement_list = $Panel/ScrollContainer/AchievementList
@onready var locked_count = $Panel/LockedCount
@onready var category_filters = $Panel/CategoryFilters

var achievement_system: AchievementSystem

func _ready():
    achievement_system = get_node("/root/AchievementSystem")
    achievement_system.achievement_formed.connect(_on_achievement_formed)
    achievement_system.achievement_earned.connect(_on_achievement_earned)
    achievement_system.achievement_locked.connect(_on_achievement_locked)
    
    _refresh_display()

func _refresh_display():
    # Clear current display
    for child in achievement_list.get_children():
        child.queue_free()
    
    # Get visible achievements
    var achievements = achievement_system.get_visible_achievements()
    
    # Sort by category and earned status
    achievements.sort_custom(func(a, b):
        if a.category != b.category:
            return a.category < b.category
        return achievement_system.has_achievement(a.id)
    )
    
    # Display each achievement
    for achievement in achievements:
        var entry = preload("res://ui/achievement_entry.tscn").instantiate()
        achievement_list.add_child(entry)
        
        entry.set_achievement(achievement)
        entry.set_earned(achievement_system.has_achievement(achievement.id))
        entry.set_progress(achievement_system.get_achievement_progress(achievement.id))
        
        # Icon shifts with dread
        entry.set_icon(achievement_system.get_achievement_icon(achievement))
    
    # Update locked count
    var locked = achievement_system.get_locked_achievements()
    locked_count.text = "Paths Forever Closed: %d" % locked.size()

func _on_achievement_formed(achievement: Achievement):
    # Subtle notification that new achievement is possible
    var notification = preload("res://ui/achievement_notification.tscn").instantiate()
    add_child(notification)
    notification.show_formed(achievement)
    
    _refresh_display()

func _on_achievement_earned(achievement: Achievement):
    # Big celebration for earning
    var celebration = preload("res://ui/achievement_celebration.tscn").instantiate()
    add_child(celebration)
    celebration.show_earned(achievement)
    
    # Update world immediately
    get_tree().call_group("npcs", "on_achievement_earned", achievement)
    
    _refresh_display()

func _on_achievement_locked(achievement_id: String):
    # Subtle indication of closed path
    var notification = preload("res://ui/path_closed_notification.tscn").instantiate()
    add_child(notification)
    notification.show_path_closed(achievement_id)

<!-- JSON: manifests/achievement_content.json -->
{
  "achievement_system": {
    "philosophy": "Achievements are the world's expectations of you based on your actions",
    "core_mechanics": {
      "dynamic_formation": "Achievements appear based on trait combinations",
      "mutual_exclusivity": "Many achievements lock out others permanently",
      "world_response": "NPCs and quests change based on earned achievements",
      "hidden_nature": "Players never see all possible achievements"
    },
    "integration_points": {
      "trait_system": "Achievements form from trait thresholds and combinations",
      "npc_system": "NPCs reference achievements in dialogue and reactions",
      "quest_system": "Available quests change based on world expectations",
      "phase_transitions": "Special achievements for each phase transition"
    },
    "categories": {
      "identity": "Who you've become through actions",
      "expectation": "What the world now expects from you",
      "transition": "Permanent marks from phase transitions",
      "dread_response": "How you handle the growing horror",
      "impossible": "Mutually exclusive life paths"
    }
  }
}

<!-- PHILOSOPHY -->
The achievement system in Dragon's Labyrinth is not about collecting badges. It's about the world recognizing and responding to who you've become. When you earn "Guardian's Guardian," NPCs start bringing their wounded to you. When you earn "Harbinger of Doom," towns evacuate as you approach.

This creates a feedback loop with the trait system:
- Traits = "I will protect" (your intentions)
- Achievements = "You must protect" (world's expectations)

The mutual exclusivity means every playthrough reveals a different subset of possible achievements, and players comparing notes will discover entirely different games based on their choices.
