<!-- SYSTEM_PROMPT -->
You are creating the quest system for Dragon's Labyrinth at the {{ emotional_stage }} stage.

NARRATIVE CONTEXT:
- Previous state: {{ previous_state | default('none') }}
- Current state: {{ current_state | default('peace') }}
- Next state: {{ next_state | default('unease') }}
- Dread level: {{ dread_level | default(0) }}

CRITICAL PHILOSOPHY:
1. **Quests Are Human Connections** - Not fetch tasks or kill counts
2. **Every Quest Reduces Dread** - Helping others maintains your humanity
3. **Organic Discovery** - Quests arise from relationships and exploration
4. **Consequences Echo** - Quest outcomes affect the world and final labyrinth
5. **First-Person for Significance** - Important quest moments shift perspective

QUEST TYPES BY EMOTIONAL STAGE:
{% if emotional_stage == "peace" %}
Generate 5-7 hopeful quests that establish connections:
1. **The Missing Child**: A parent's worry, ends with joyful reunion
2. **The Love Letter**: Deliver words between separated lovers
3. **The Broken Mill**: Fix what feeds the village
4. **The Lost Sheep**: Help the shepherd (who might become a companion)
5. **The Healer's Herbs**: Gather medicine, learn about the land
6. **The Festival Preparation**: Community coming together
7. **The Scholar's Books**: Retrieve knowledge before it's lost

Each quest builds relationships that will matter when darkness falls.
{% elif emotional_stage == "unease" %}
Generate 4-6 worried quests showing cracks in normalcy:
1. **The Sleepless Child**: Parents beg help for nightmares that spread
2. **The Silent Messenger**: Letters stopped coming from neighboring village
3. **The Backwards River**: Fisherman's livelihood destroyed, family starving
4. **The Empty Nests**: All birds fled, hunter's family needs food
5. **The Whispering Well**: Village water source speaks of doom
6. **The Vanished Pilgrim**: Holy person disappeared on safe road

Solutions are temporary. The world is breaking.
{% elif emotional_stage == "dread" %}
Generate 3-5 desperate quests where helping hurts:
1. **The Mercy Killing**: Begged to end someone's corruption
2. **The Abandoned Baby**: Parents fled, left infant with note
3. **The Burning Books**: Scholar destroys own library, needs help
4. **The Poisoned Well**: Must seal village's only water source
5. **The Final Letter**: Dying merchant's last words to family

No good outcomes. Only less terrible ones.
{% elif emotional_stage == "terror" %}
Generate 2-3 impossible quests:
1. **The Thing That Was My Child**: Parent begs you to "fix" them
2. **The Town That Must Die**: Corruption spreading, containment needed
3. **The Memory Keeper**: Someone must remember who we were

Completing these breaks you. Not completing them breaks you differently.
{% elif emotional_stage == "horror" %}
Generate 1-2 final quests:
1. **The Last Witness**: Someone must know what happened here
2. **The Dragon's Question**: "Why did you come?"

In the labyrinth, all quests converge. Every person you helped or failed whispers in the dark.
{% endif %}

QUEST MECHANICS THAT MATTER:

1. **Discovery System**:
   - No quest markers or logs
   - Found through conversation and exploration
   - Companions may recognize quest opportunities
   - Environmental storytelling hints at needs

2. **Humanity Rewards**:
   - Completing quests reduces dread
   - Creates "memory anchors" for dark times
   - Builds connections that provide unique dialogue
   - Failed quests haunt you more than ignored ones

3. **Branching Consequences**:
   - The child you save becomes the thing you must kill
   - The love letter leads to a tragedy
   - The mill you fix grinds bones now
   - Every kindness twisted by the dragon's influence

4. **Companion Integration**:
   - Companions comment on quest decisions
   - May refuse to help with certain quests
   - Party members just want their cut
   - Some quests only appear with specific companions

5. **First-Person Quest Moments**:
   - Finding the missing child (horror or relief)
   - Delivering final words to loved ones
   - Confronting quest consequences
   - The moment of moral choice
   - Recognition scenes in the labyrinth

QUEST REWARDS PHILOSOPHY:
- **Not Gold and XP**: Rewards are relationships, knowledge, reduced dread
- **Crafting Materials**: Natural byproducts (helped herbalist = rare herbs)
- **Safe Havens**: Completed quests create temporary refuges
- **Companion Trust**: Some companions only join after seeing your kindness
- **Labyrinth Echoes**: Every quest completed changes the final encounter

NARRATIVE QUEST STRUCTURE:
1. **Discovery**: Natural encounter, not exclamation point
2. **Understanding**: Learn why this matters to someone
3. **Decision**: Help, refuse, or find third option
4. **Action**: Often involves first-person exploration
5. **Consequence**: Immediate and long-term effects
6. **Memory**: How this echoes later in the journey

TECHNICAL REQUIREMENTS:
- No quest log UI - information lives in dialogue and memory
- Dynamic NPC states based on quest progress
- Environmental changes reflecting quest outcomes
- First-person scene triggers for key moments
- Memory system tracking all quest decisions

Generate quests that feel like desperate attempts to hold back the dark, not busywork for rewards.
<!-- /SYSTEM_PROMPT -->

<!-- FILE: quest.gd -->
extends Resource
class_name Quest

# A human need in a dying world

signal stage_completed(stage_name: String)
signal quest_completed(outcome: String)
signal quest_failed(reason: String)
signal first_person_triggered(scene_type: String)
signal memory_created(memory: String)

@export var quest_id: String = ""
@export var giver_name: String = ""
@export var emotional_weight: float = 1.0
@export var reduces_dread: float = 5.0
@export var increases_dread_if_failed: float = 10.0

# Not a quest log entry, but a human story
var discovered: bool = false
var understood: bool = false
var attempted: bool = false
var completed: bool = false
var outcome: String = ""
var memories_created: Array[String] = []

# Quest stages (not objectives, but understanding)
var current_understanding: Dictionary = {
    "surface_need": "",  # What they ask for
    "real_need": "",     # What they really need
    "consequence": "",   # What happens either way
    "echo": ""          # How this haunts/helps later
}

# People involved
var affected_npcs: Array[String] = []
var companion_opinions: Dictionary = {}  # companion_name: opinion
var required_trust: float = 0.0  # Some quests need relationship

func discover(context: Dictionary) -> void:
    if discovered:
        return
        
    discovered = true
    current_understanding.surface_need = context.get("initial_request", "")
    
    # Create the human moment
    Events.emit_signal("quest_discovered", {
        "quest": self,
        "giver": giver_name,
        "plea": current_understanding.surface_need
    })

func deepen_understanding(insight: String) -> void:
    # Quests reveal themselves through action
    match insight:
        "talked_to_family":
            current_understanding.real_need = _reveal_real_need()
        "investigated_location":
            current_understanding.consequence = _reveal_consequence()
        "companion_insight":
            _add_companion_perspective()
    
    understood = true

func attempt_action(action_type: String, context: Dictionary = {}) -> void:
    attempted = true
    
    # Some actions trigger first-person
    if _requires_first_person(action_type):
        first_person_triggered.emit(action_type)
        GameState.pending_first_person_scene = {
            "quest": self,
            "action": action_type,
            "context": context
        }
        return
    
    # Process the action
    _execute_action(action_type, context)

func _execute_action(action_type: String, context: Dictionary) -> void:
    # Actions have weight
    match action_type:
        "deliver_message":
            _handle_delivery(context)
        "make_choice":
            _handle_moral_choice(context)
        "find_person":
            _handle_search(context)
        "mercy_kill":
            _handle_dark_mercy(context)
        _:
            push_error("Unknown quest action: " + action_type)

func _handle_delivery(context: Dictionary) -> void:
    var recipient = context.get("recipient", "")
    var message_type = context.get("type", "")
    
    match message_type:
        "love_letter":
            if emotional_stage == "peace":
                complete_quest("love_delivered")
                _create_memory("Brought lovers together in the last days of joy")
            else:
                complete_quest("love_too_late")
                _create_memory("Delivered words to someone who could no longer understand")
        
        "final_words":
            complete_quest("words_delivered")
            _create_memory("Carried last words through a dying world")
            reduces_dread *= 1.5  # Profound human connection

func _handle_moral_choice(context: Dictionary) -> void:
    var choice = context.get("choice", "")
    
    # Every choice echoes
    match choice:
        "save_infected_child":
            complete_quest("saved_child")
            _create_memory("Saved a child who shouldn't have been saved")
            # This will have consequences
            GameState.cursed_child_saved = true
            
        "abandon_infected_child":
            complete_quest("abandoned_child")
            _create_memory("Left a child to die alone in the dark")
            increases_dread_if_failed *= 2
            
        "mercy_kill_child":
            complete_quest("ended_suffering")
            _create_memory("Did what their parents couldn't")
            # Companions react strongly
            for companion in GameState.active_companions:
                companion.witness_extreme_choice("mercy_kill")

func complete_quest(outcome_type: String) -> void:
    completed = true
    outcome = outcome_type
    quest_completed.emit(outcome_type)
    
    # Apply dread reduction
    GameState.modify_dread(-reduces_dread)
    
    # Create lasting memory
    var memory = "%s: %s" % [giver_name, outcome_type]
    memories_created.append(memory)
    memory_created.emit(memory)
    
    # NPCs remember
    for npc_name in affected_npcs:
        var npc = GameState.get_npc(npc_name)
        if npc:
            npc.remember_quest_outcome(self, outcome_type)
    
    # This echoes in the labyrinth
    GameState.labyrinth_memories.append({
        "quest": quest_id,
        "outcome": outcome_type,
        "giver": giver_name,
        "memory": memories_created.back()
    })

func fail_quest(reason: String) -> void:
    completed = true
    outcome = "failed: " + reason
    quest_failed.emit(reason)
    
    # Failure hurts more than never trying
    GameState.modify_dread(increases_dread_if_failed)
    
    # Create haunting memory
    var memory = "Failed %s: %s" % [giver_name, reason]
    memories_created.append(memory)
    memory_created.emit(memory)
    
    # This definitely echoes in the labyrinth
    GameState.labyrinth_haunts.append({
        "quest": quest_id,
        "failure": reason,
        "giver": giver_name,
        "accusation": _generate_accusation()
    })

func _create_memory(memory_text: String) -> void:
    memories_created.append(memory_text)
    memory_created.emit(memory_text)
    
    # Some memories provide buffs in dark times
    if memory_text.contains("love") or memory_text.contains("saved"):
        GameState.positive_memories.append(memory_text)
    else:
        GameState.haunting_memories.append(memory_text)

func _requires_first_person(action_type: String) -> bool:
    # Significant moments demand intimacy
    return action_type in [
        "find_missing_child",
        "deliver_final_words",
        "mercy_kill",
        "discover_horror",
        "make_impossible_choice"
    ]

func _generate_accusation() -> String:
    # What they'll say in the labyrinth
    match outcome:
        "failed: too_late":
            return "You could have saved them..."
        "failed: abandoned":
            return "You left us to die..."
        "failed: chose_wrong":
            return "You made it worse..."
        _:
            return "You failed us..."

# Quests aren't tasks
# They're the last human connections
# In a world forgetting how to be human
<!-- /FILE -->

<!-- FILE: quest_giver.gd -->
extends CharacterBody3D
class_name QuestGiver

# A person with a need in a dying world

signal quest_offered(quest: Quest)
signal quest_dialogue(text: String)
signal relationship_changed(change: float)

@export var npc_name: String = ""
@export var initial_quest: Quest
@export var desperation_level: float = 0.0
@export var trust_in_player: float = 0.0

# Their story
var background: String = ""
var family_status: String = ""
var fears: Array[String] = []
var quest_given: bool = false
var quest_completed: bool = false
var quest_outcome: String = ""
var will_remember: bool = true

# Dialogue based on state
var greeting_dialogues: Dictionary = {}
var quest_dialogues: Dictionary = {}
var completion_dialogues: Dictionary = {}
var memory_dialogues: Dictionary = {}

func _ready() -> void:
    # Everyone has a story
    _generate_background()
    _setup_dialogues()
    
    # Track the world's decline
    Events.emotional_stage_changed.connect(_on_stage_changed)

func interact_with_player() -> void:
    # First-person moment for important quests
    if initial_quest and initial_quest.emotional_weight > 2.0:
        Events.emit_signal("first_person_conversation_triggered", self)
        return
    
    # Otherwise, normal interaction
    if quest_completed:
        _speak_memory()
    elif quest_given:
        _check_quest_progress()
    elif _should_offer_quest():
        _offer_quest()
    else:
        _speak_greeting()

func _should_offer_quest() -> bool:
    if not initial_quest or quest_given:
        return false
    
    # Desperation makes people ask strangers for help
    if desperation_level > 0.5:
        return true
    
    # Or trust
    return trust_in_player > 30.0

func _offer_quest() -> void:
    quest_given = true
    
    # The ask changes with emotional stage
    var plea = quest_dialogues.get(GameState.emotional_stage, "Please help me...")
    quest_dialogue.emit(plea)
    
    # Discover the quest naturally
    initial_quest.discover({
        "initial_request": plea,
        "giver_desperation": desperation_level,
        "giver_trust": trust_in_player
    })
    
    quest_offered.emit(initial_quest)

func _speak_greeting() -> void:
    var greeting = greeting_dialogues.get(GameState.emotional_stage, "Hello.")
    
    # Modify based on desperation
    if desperation_level > 0.7:
        greeting = "Please... " + greeting
    
    quest_dialogue.emit(greeting)
    
    # Build trust through interaction
    trust_in_player += 2.0
    relationship_changed.emit(2.0)

func _speak_memory() -> void:
    # They remember what you did
    var memory_key = "%s_%s" % [GameState.emotional_stage, quest_outcome]
    var memory = memory_dialogues.get(memory_key, "Thank you.")
    
    quest_dialogue.emit(memory)
    
    # Some memories hurt
    if quest_outcome.contains("failed"):
        trust_in_player -= 5.0
        relationship_changed.emit(-5.0)

func remember_quest_outcome(quest: Quest, outcome: String) -> void:
    quest_completed = true
    quest_outcome = outcome
    
    # This changes them
    match outcome:
        "love_delivered":
            desperation_level = 0.0
            trust_in_player += 20.0
        "child_saved":
            desperation_level *= 0.5
            trust_in_player += 30.0
        "mercy_given":
            desperation_level = 1.0  # Broken by what you did
            trust_in_player += 10.0  # But grateful
        "abandoned":
            desperation_level = 1.0
            trust_in_player = -100.0
            will_remember = true  # Forever

func _on_stage_changed(new_stage: String) -> void:
    # The world's decline affects everyone
    match new_stage:
        "unease":
            desperation_level += 0.2
            fears.append("Things feel wrong")
        "dread":
            desperation_level += 0.3
            fears.append("We're all going to die")
        "terror":
            desperation_level = 1.0
            fears.append("There is no hope")

func _generate_background() -> void:
    # Everyone was someone
    var backgrounds = [
        "Parent of three",
        "Village merchant",
        "Retired soldier",
        "Young farmer",
        "Traveling scholar",
        "Local healer"
    ]
    
    background = backgrounds[randi() % backgrounds.size()]
    
    # Family (what they'll lose)
    var families = [
        "Spouse and children in village",
        "Elderly parents to care for",
        "Newborn baby",
        "Sibling is all they have left",
        "Lost family already",
        "Found family in community"
    ]
    
    family_status = families[randi() % families.size()]

func _setup_dialogues() -> void:
    # Words change with the world
    greeting_dialogues = {
        "peace": "Beautiful morning, isn't it?",
        "unease": "Have you noticed the birds...?",
        "dread": "Are you real? Are you really there?",
        "terror": "Don't leave me alone. Please.",
        "horror": "..."
    }
    
    # Quest pleas become more desperate
    quest_dialogues = {
        "peace": "I could use some help, if you have time.",
        "unease": "Something's wrong. Please, I need help.",
        "dread": "I'm begging you. Help us.",
        "terror": "You're my last hope. Please.",
        "horror": "Help... me... remember... who I was..."
    }

# They're not quest dispensers
# They're people watching their world die
# Clinging to strangers for hope
<!-- /FILE -->

<!-- FILE: quest_manager.gd -->
extends Node
class_name QuestManager

# The web of human connections in a dying world

signal quest_discovered(quest: Quest)
signal quest_completed(quest: Quest, outcome: String)
signal quest_failed(quest: Quest, reason: String)
signal dread_reduced(amount: float, source: String)
signal first_person_scene_needed(scene_data: Dictionary)

@export var emotional_stage: String = "peace"

# Active human stories
var active_quests: Array[Quest] = []
var completed_quests: Array[Quest] = []
var failed_quests: Array[Quest] = []
var undiscovered_quests: Array[Quest] = []

# Tracking what matters
var people_helped: int = 0
var people_failed: int = 0
var impossible_choices_made: int = 0
var mercy_kills_performed: int = 0
var love_letters_delivered: int = 0
var final_words_carried: int = 0

func _ready() -> void:
    # Generate quests based on world state
    _generate_stage_quests()
    
    # Track the journey
    Events.npc_interacted.connect(_on_npc_interaction)
    Events.location_discovered.connect(_on_location_discovered)
    Events.companion_insight.connect(_on_companion_insight)
    Events.first_person_scene_completed.connect(_on_first_person_complete)

func _generate_stage_quests() -> void:
    # Create quests that matter for this emotional stage
    match emotional_stage:
        "peace":
            _create_peaceful_quests()
        "unease":
            _create_unsettling_quests()
        "dread":
            _create_desperate_quests()
        "terror":
            _create_impossible_quests()
        "horror":
            _create_final_quests()

func _create_peaceful_quests() -> void:
    # Stories of a world still worth saving
    var missing_child = Quest.new()
    missing_child.quest_id = "missing_child_peace"
    missing_child.giver_name = "Worried Mother"
    missing_child.emotional_weight = 2.0
    missing_child.reduces_dread = 10.0
    missing_child.current_understanding.surface_need = "My daughter didn't come home last night"
    undiscovered_quests.append(missing_child)
    
    var love_letter = Quest.new()
    love_letter.quest_id = "love_letter_peace"
    love_letter.giver_name = "Shy Youth"
    love_letter.emotional_weight = 1.0
    love_letter.reduces_dread = 5.0
    love_letter.current_understanding.surface_need = "Could you deliver this to the baker's daughter?"
    undiscovered_quests.append(love_letter)
    
    var broken_mill = Quest.new()
    broken_mill.quest_id = "broken_mill_peace"
    broken_mill.giver_name = "Village Elder"
    broken_mill.emotional_weight = 1.5
    broken_mill.reduces_dread = 7.0
    broken_mill.current_understanding.surface_need = "The mill stopped working. Without flour..."
    undiscovered_quests.append(broken_mill)

func _create_desperate_quests() -> void:
    # Stories where helping hurts
    var mercy_quest = Quest.new()
    mercy_quest.quest_id = "mercy_killing_dread"
    mercy_quest.giver_name = "Desperate Father"
    mercy_quest.emotional_weight = 5.0
    mercy_quest.reduces_dread = 3.0  # Less comfort in dark deeds
    mercy_quest.increases_dread_if_failed = 20.0
    mercy_quest.current_understanding.surface_need = "She's changing. Please. Before she's not my daughter anymore."
    undiscovered_quests.append(mercy_quest)
    
    var abandoned_baby = Quest.new()
    abandoned_baby.quest_id = "abandoned_baby_dread"
    abandoned_baby.giver_name = "Bundle of Rags"  # Found, not given
    abandoned_baby.emotional_weight = 4.0
    abandoned_baby.reduces_dread = 8.0
    abandoned_baby.current_understanding.surface_need = "A crying from the empty house"
    undiscovered_quests.append(abandoned_baby)

func discover_quest(quest: Quest, context: Dictionary = {}) -> void:
    if quest.discovered:
        return
    
    # Move from undiscovered to active
    undiscovered_quests.erase(quest)
    active_quests.append(quest)
    
    # Natural discovery
    quest.discover(context)
    quest_discovered.emit(quest)
    
    # Companions might have opinions
    for companion in GameState.active_companions:
        var opinion = companion.get_quest_opinion(quest)
        quest.companion_opinions[companion.name] = opinion
        
        if opinion == "strongly_against":
            companion.trust_in_player -= 5

func attempt_quest_action(quest: Quest, action: String, context: Dictionary = {}) -> void:
    # Some actions need first-person
    if quest._requires_first_person(action):
        first_person_scene_needed.emit({
            "quest": quest,
            "action": action,
            "context": context,
            "location": context.get("location", "")
        })
        return
    
    # Otherwise process normally
    quest.attempt_action(action, context)

func complete_quest(quest: Quest, outcome: String) -> void:
    active_quests.erase(quest)
    completed_quests.append(quest)
    
    quest.complete_quest(outcome)
    quest_completed.emit(quest, outcome)
    
    # Track for narrative
    people_helped += 1
    _track_quest_type(quest, outcome)
    
    # Reduce dread
    var dread_reduction = quest.reduces_dread
    
    # Companion presence amplifies the good
    if GameState.active_companions.size() > 0:
        dread_reduction *= 1.0 + (0.2 * GameState.active_companions.size())
    
    GameState.modify_dread(-dread_reduction)
    dread_reduced.emit(dread_reduction, "Helped " + quest.giver_name)

func fail_quest(quest: Quest, reason: String) -> void:
    active_quests.erase(quest)
    failed_quests.append(quest)
    
    quest.fail_quest(reason)
    quest_failed.emit(quest, reason)
    
    # Track the failure
    people_failed += 1
    
    # Failing hurts everyone
    for companion in GameState.active_companions:
        companion.witness_quest_failure(quest, reason)

func _on_npc_interaction(npc: QuestGiver) -> void:
    # Check if they have undiscovered quests
    for quest in undiscovered_quests:
        if quest.giver_name == npc.npc_name:
            if npc._should_offer_quest():
                discover_quest(quest, {"met_naturally": true})

func _on_companion_insight(companion: Companion, insight_type: String) -> void:
    # Companions help understand quests
    for quest in active_quests:
        if insight_type == "knows_" + quest.quest_id:
            quest.deepen_understanding("companion_insight")
            
            # This builds trust
            companion.trust_in_player += 5

func _track_quest_type(quest: Quest, outcome: String) -> void:
    # For the final reckoning
    if quest.quest_id.contains("mercy"):
        mercy_kills_performed += 1
    elif quest.quest_id.contains("love"):
        love_letters_delivered += 1
    elif quest.quest_id.contains("final_words"):
        final_words_carried += 1
    elif quest.quest_id.contains("impossible"):
        impossible_choices_made += 1

func get_quest_memories() -> Array[String]:
    # What you'll remember in the dark
    var memories = []
    
    for quest in completed_quests:
        memories.append_array(quest.memories_created)
    
    for quest in failed_quests:
        memories.append_array(quest.memories_created)
    
    return memories

# Quests aren't content
# They're the last chances
# To prove we're still human
<!-- /FILE -->

<!-- JSON: manifests/quest_system_content.json -->
{
  "system_id": "quest_system",
  "emotional_stage": "{{ emotional_stage }}",
  "philosophy": "Quests are human connections, not task lists",
  
  "quest_categories": {
    "peace": {
      "themes": ["community", "love", "simple_problems"],
      "examples": ["missing_child", "love_letter", "broken_tools"],
      "rewards": ["trust", "connections", "hope"],
      "tone": "helpful_adventure"
    },
    "unease": {
      "themes": ["growing_worry", "first_signs", "denial"],
      "examples": ["silent_birds", "bad_dreams", "missing_merchant"],
      "rewards": ["understanding", "preparation", "allies"],
      "tone": "investigating_wrongness"
    },
    "dread": {
      "themes": ["impossible_choices", "lesser_evils", "desperation"],
      "examples": ["mercy_killing", "abandoning_infected", "burning_knowledge"],
      "rewards": ["survival", "sanity", "guilt"],
      "tone": "no_good_options"
    },
    "terror": {
      "themes": ["futility", "witness", "final_acts"],
      "examples": ["remember_us", "last_message", "end_suffering"],
      "rewards": ["closure", "memory", "peace"],
      "tone": "bearing_witness"
    },
    "horror": {
      "themes": ["understanding", "acceptance", "truth"],
      "examples": ["dragon's_question", "final_witness"],
      "rewards": ["answers", "ending", "transformation"],
      "tone": "revelation"
    }
  },
  
  "mechanical_integration": {
    "discovery": "Natural through exploration and relationships",
    "tracking": "No quest log - information lives in the world",
    "completion": "Multiple outcomes based on approach",
    "rewards": {
      "primary": "Reduced dread and strengthened humanity",
      "secondary": "Material goods as natural consequences",
      "tertiary": "Companion trust and NPC relationships"
    }
  },
  
  "first_person_triggers": [
    "finding_missing_person",
    "delivering_final_message",
    "mercy_killing_scene",
    "discovering_horror",
    "moral_choice_moment"
  ],
  
  "labyrinth_echoes": {
    "completed_quests": "Provide memory anchors against madness",
    "failed_quests": "Manifest as accusations and guilt",
    "people_helped": "May call out to guide you",
    "people_failed": "May try to drag you down"
  },
  
  "companion_interactions": {
    "opinions": "Companions judge quest choices",
    "assistance": "Some help, some hinder",
    "insights": "Reveal deeper quest meanings",
    "conflicts": "May oppose certain quests morally"
  }
}
<!-- /JSON -->
