# The Consumption Transition - Dragon's Labyrinth
# Dark Path: Madness â†’ Void
# Theme: Becoming what you fought to gain ultimate power

extends Node
class_name TheConsumptionTransition

## Core Design: Consume everything - allies, enemies, reality itself
## Revelation: This is how the void was born - from consuming to protect

signal transition_complete(outcome: Dictionary)
signal entity_consumed(entity: Dictionary, power_gained: float)
signal void_merger_progressed(merger_level: float, reversible: bool)
signal reality_layer_devoured(layer: String, stability_remaining: float)
signal consciousness_fragmented(fragment: String, coherence: float)
signal final_choice_presented(options: Array)

@export_group("Transition Settings")
@export var consumption_ground: String = "The Final Feast"
@export var entities_available: int = 1000  # Everything that exists
@export var void_merger_threshold: float = 0.8
@export var reality_layers: int = 7
@export var time_until_collapse: int = 24  # Hours

@export_group("Consumption Mechanics")
@export var companion_power_multiplier: float = 10.0
@export var innocent_power_multiplier: float = 3.0
@export var reality_fragment_power: float = 50.0
@export var void_entity_power: float = 100.0
@export var self_consumption_power: float = 200.0

@export_group("Scaling Settings")
@export var group_consumption_efficiency: float = 1.5
@export var solo_void_communion: float = 3.0
@export var love_betrayal_power: float = 5.0

var _world_state: Node
var _party_manager: Node
var _trait_system: Node
var _achievement_system: Node
var _companion_system: Node

var _consumable_entities: Array[Dictionary] = []
var _consumed_entities: Array[Dictionary] = []
var _total_power_accumulated: float = 0.0
var _void_merger_level: float = 0.0
var _reality_stability: float = 1.0
var _consciousness_coherence: float = 1.0
var _layers_consumed: Array[String] = []
var _time_remaining: int = 0
var _revelation_stages: Array[bool] = [false, false, false]

## Three Versions of the Transition
enum TransitionVersion {
	TO_LABYRINTH,    # Consuming to face dragon
	FROM_LABYRINTH,  # Void demands you become new prison
	SEALING_VOID     # Mutual consumption with void
}

@export var current_version: TransitionVersion = TransitionVersion.TO_LABYRINTH

func _ready() -> void:
	_world_state = get_node("/root/WorldState")
	_party_manager = get_node("/root/PartyManager")
	_trait_system = get_node("/root/TraitSystem")
	_achievement_system = get_node("/root/AchievementSystem")
	_companion_system = get_node("/root/CompanionSystem")
	
	_initialize_consumption_state()

func _initialize_consumption_state() -> void:
	# Everything becomes consumable
	_categorize_all_existence()
	
	# Calculate starting void connection
	_calculate_void_affinity()
	
	# Begin countdown
	_time_remaining = time_until_collapse

## The Final Hunger: Everything is Food
func _categorize_all_existence() -> void:
	# Companions (highest value)
	for companion in _companion_system.get_all_companions():
		_consumable_entities.append({
			"id": companion.id,
			"name": companion.name,
			"type": "companion",
			"power_value": companion.bond_level * companion_power_multiplier,
			"emotional_weight": companion.shared_memories.size(),
			"special": "betrayal_of_love"
		})
	
	# Mercenaries
	for i in range(_party_manager.get_mercenary_count()):
		_consumable_entities.append({
			"id": "mercenary_" + str(i),
			"name": "Mercenary " + str(i),
			"type": "mercenary",
			"power_value": 5.0,
			"emotional_weight": 1.0,
			"special": "none"
		})
	
	# NPCs and civilians
	var npcs = _world_state.get_all_npcs()
	for npc in npcs:
		_consumable_entities.append({
			"id": npc.id,
			"name": npc.name,
			"type": "npc",
			"power_value": _calculate_npc_power(npc),
			"emotional_weight": _calculate_npc_weight(npc),
			"special": _determine_npc_special(npc)
		})
	
	# Void entities (dangerous but powerful)
	for i in range(10):
		_consumable_entities.append({
			"id": "void_entity_" + str(i),
			"name": "Void Fragment " + str(i),
			"type": "void_entity",
			"power_value": void_entity_power,
			"emotional_weight": 0,
			"special": "corrupts_further"
		})
	
	# Reality itself
	for layer in ["physical", "temporal", "causal", "conceptual", "emotional", "spiritual", "fundamental"]:
		_consumable_entities.append({
			"id": "reality_" + layer,
			"name": layer.capitalize() + " Reality",
			"type": "reality_layer",
			"power_value": reality_fragment_power,
			"emotional_weight": 0,
			"special": "destabilizes_existence"
		})
	
	# Yourself (the ultimate consumption)
	_consumable_entities.append({
		"id": "self",
		"name": "Your Own Essence",
		"type": "self",
		"power_value": self_consumption_power,
		"emotional_weight": 999,
		"special": "final_transformation"
	})

func start_transition() -> void:
	_present_consumption_revelation()
	
	match current_version:
		TransitionVersion.TO_LABYRINTH:
			_begin_power_accumulation()
		TransitionVersion.FROM_LABYRINTH:
			_begin_void_succession()
		TransitionVersion.SEALING_VOID:
			_begin_mutual_annihilation()

## Core Mechanic: Devour to Ascend
func consume_entity(target: Dictionary) -> Dictionary:
	var result = {
		"success": false,
		"power_gained": 0.0,
		"merger_increase": 0.0,
		"side_effects": [],
		"consciousness_impact": 0.0,
		"permanence": true
	}
	
	# Calculate consumption success
	var success_chance = _calculate_consumption_chance(target)
	
	if randf() < success_chance:
		result.success = true
		
		# Power gained
		result.power_gained = target.power_value
		if target.type == "companion" and target.emotional_weight > 50:
			result.power_gained *= love_betrayal_power
		
		_total_power_accumulated += result.power_gained
		
		# Void merger progresses
		result.merger_increase = _calculate_merger_increase(target)
		_void_merger_level += result.merger_increase
		
		# Side effects based on what was consumed
		match target.type:
			"companion":
				result.side_effects.append("soul_shattered")
				result.side_effects.append("love_inverted")
				_consciousness_coherence -= 0.1
			"reality_layer":
				result.side_effects.append("reality_unstable")
				_reality_stability -= 0.15
				_layers_consumed.append(target.id)
			"void_entity":
				result.side_effects.append("void_corruption_deepened")
				_void_merger_level += 0.1
			"self":
				result.side_effects.append("final_transformation_begun")
				_begin_apotheosis()
		
		# Track consumption
		_consumed_entities.append(target)
		entity_consumed.emit(target, result.power_gained)
		
		# Remove from available
		_consumable_entities.erase(target)
		
		# Check transformations
		_check_consumption_transformation()
	else:
		# Failed consumption has consequences
		result.side_effects.append("consumption_resisted")
		if target.type == "void_entity":
			result.side_effects.append("void_retaliates")
			_void_punishment()
	
	# Check revelations
	_check_consumption_revelations()
	
	return result

func _calculate_consumption_chance(target: Dictionary) -> float:
	var base_chance = 0.7
	
	# Void merger level increases success
	base_chance += _void_merger_level * 0.3
	
	# Target type affects difficulty
	match target.type:
		"companion":
			# Harder if high bond
			base_chance -= target.emotional_weight * 0.001
		"void_entity":
			# Dangerous but easier with corruption
			base_chance += _current_corruption * 0.2
		"reality_layer":
			# Harder as reality destabilizes
			base_chance -= (1.0 - _reality_stability) * 0.5
		"self":
			# Only possible at extreme merger
			base_chance = _void_merger_level
	
	return clamp(base_chance, 0.1, 0.95)

## The Horror: Perspective Shift as You Transform
func _check_consumption_transformation() -> void:
	# Track void merger progression
	var reversible = _void_merger_level < void_merger_threshold
	void_merger_progressed.emit(_void_merger_level, reversible)
	
	# Different stages of becoming void
	if _void_merger_level >= 0.2 and not _revelation_stages[0]:
		_reveal_first_shift()
	elif _void_merger_level >= 0.5 and not _revelation_stages[1]:
		_reveal_second_shift()
	elif _void_merger_level >= 0.8 and not _revelation_stages[2]:
		_reveal_final_understanding()

func _reveal_first_shift() -> void:
	# You start seeing from void's perspective
	var revelation = "The consumed whisper within you. Their power flows through void-space. You ARE the void they feared."
	_world_state.trigger_perspective_shift("void_sight")
	consciousness_fragmented.emit("empathy", _consciousness_coherence)
	_revelation_stages[0] = true

func _reveal_second_shift() -> void:
	# Understanding the dragon's burden
	var revelation = "Memory not yours surfaces: The dragon stood here. Chose guardianship over consumption. Chose chains over hunger. Fool."
	_world_state.trigger_perspective_shift("void_memory")
	consciousness_fragmented.emit("identity", _consciousness_coherence)
	_revelation_stages[1] = true

func _reveal_final_understanding() -> void:
	# The final revelation
	var revelation = "You understand. The void was once like you. Consumed to protect. Became the threat. The cycle continues. You ARE the cycle."
	_world_state.trigger_perspective_shift("void_truth")
	consciousness_fragmented.emit("self", 0)
	_revelation_stages[2] = true
	
	# Present the final choice
	_present_ultimate_choice()

## The Final Choice: What Kind of Void Will You Be?
func _present_ultimate_choice() -> void:
	var final_options = []
	
	# Option 1: Complete consumption - become new void
	final_options.append({
		"id": "become_void",
		"text": "Consume everything. Become the new void. Eternal hunger, eternal power.",
		"requirement": _total_power_accumulated > 1000,
		"outcome": "new_void_born",
		"ending_type": "dark_apotheosis"
	})
	
	# Option 2: Consume the old void - mutual annihilation
	if "void_entity" in _get_consumed_types():
		final_options.append({
			"id": "consume_void",
			"text": "Turn your hunger on the void itself. Devour the devourer.",
			"requirement": _void_merger_level > 0.9,
			"outcome": "mutual_consumption",
			"ending_type": "dark_sacrifice"
		})
	
	# Option 3: Become prison - contain yourself
	if _consciousness_coherence > 0.1:
		final_options.append({
			"id": "self_prison",
			"text": "Use last fragment of will. Become both void and prison. Eternal struggle.",
			"requirement": true,
			"outcome": "living_seal",
			"ending_type": "dark_redemption"
		})
	
	# Option 4: Consume reality itself - end everything
	if _layers_consumed.size() >= 5:
		final_options.append({
			"id": "end_all",
			"text": "Consume the fundamental layer. End existence. Final silence.",
			"requirement": _reality_stability < 0.2,
			"outcome": "reality_devoured",
			"ending_type": "true_void"
		})
	
	final_choice_presented.emit(final_options)
	_world_state.present_apotheosis_choice(final_options, self, "_on_final_choice_made")

func _on_final_choice_made(choice: Dictionary) -> void:
	match choice.id:
		"become_void":
			_complete_void_transformation()
		"consume_void":
			_initiate_void_consumption()
		"self_prison":
			_become_living_seal()
		"end_all":
			_devour_reality_fundamental()
	
	# Complete transition with chosen ending
	_complete_transition(choice.outcome)

## Journey FROM Labyrinth - Void Succession
func _begin_void_succession() -> void:
	# Old void is dying, demands successor
	_world_state.void_speaks("The prison fails. The guardian falls. You consumed to reach here. Now consume to replace. Become what must be.")
	
	# Everything is easier to consume
	for entity in _consumable_entities:
		entity.power_value *= 2.0

## Sealing the Void - Mutual Consumption
func _begin_mutual_annihilation() -> void:
	# Race to consume void before it consumes you
	_spawn_void_aspects_to_consume()
	_accelerate_merger_rate()

## Mass Consumption Events
func perform_mass_consumption(radius: String) -> void:
	var consumed_count = 0
	var total_power = 0.0
	
	# Consume based on radius
	match radius:
		"room":
			consumed_count = 10
			total_power = 50
		"building":
			consumed_count = 50
			total_power = 200
		"district":
			consumed_count = 200
			total_power = 800
		"city":
			consumed_count = 1000
			total_power = 3000
		"region":
			consumed_count = 5000
			total_power = 10000
		"world":
			# The final consumption
			_consume_entire_world()
			return
	
	# Apply consumption
	_total_power_accumulated += total_power
	_void_merger_level = min(1.0, _void_merger_level + consumed_count * 0.0001)
	
	# Reality screams
	_reality_stability -= consumed_count * 0.0001
	reality_layer_devoured.emit("population_layer", _reality_stability)

## Dark Path Consequences
func _apply_permanent_consumption_consequences() -> void:
	# You are no longer recognizable as human
	_world_state.player_becomes("living_void")
	
	# All companions either consumed or fled
	for companion in _companion_system.get_all_companions():
		if companion.id in _get_consumed_ids():
			companion.state = "consumed_by_player"
			companion.exists = false
		else:
			companion.state = "fled_in_terror"
			companion.location = "far_from_monster"
	
	# Reality bears scars
	for layer in _layers_consumed:
		_world_state.reality_damage(layer, "permanently_weakened")
	
	# You are the new threat
	_world_state.add_new_evil(_party_manager.get_player().name, {
		"type": "void_incarnate",
		"power": _total_power_accumulated,
		"threat_level": "apocalyptic",
		"containable": false
	})

func _complete_void_transformation() -> void:
	# You become the new void
	_trait_system.replace_all_traits(_party_manager.get_player(), ["THE_HUNGER", "VOID_ITSELF", "ETERNAL_CONSUMER"])
	
	# New game+ unlocked where you're the final boss
	_world_state.unlock_newgame_plus("play_as_void")

func _complete_transition(outcome: String) -> void:
	var result = {
		"transition": "the_consumption",
		"path": "dark",
		"outcome": outcome,
		"entities_consumed": _consumed_entities.size(),
		"total_power": _total_power_accumulated,
		"void_merger": _void_merger_level,
		"reality_stability": _reality_stability,
		"consciousness_coherence": _consciousness_coherence,
		"layers_devoured": _layers_consumed,
		"revelations": _revelation_stages,
		"became_void": _void_merger_level >= 1.0
	}
	
	# Apply permanent changes
	_apply_permanent_consumption_consequences()
	
	# Update world state
	_world_state.set_consumption_outcome(consumption_ground, result)
	
	transition_complete.emit(result)

## Helper Functions
func _calculate_void_affinity() -> void:
	var player = _party_manager.get_player()
	
	# Previous consumption increases starting merger
	if _trait_system.has_trait(player, "the_final_hunger"):
		_void_merger_level += 0.3
	if _trait_system.has_trait(player, "hollow_one"):
		_void_merger_level += 0.2
	if _trait_system.has_trait(player, "void_avatar"):
		_void_merger_level += 0.1

func _calculate_npc_power(npc: Dictionary) -> float:
	var base_power = 1.0
	
	if npc.has("importance"):
		match npc.importance:
			"critical":
				base_power = 10.0
			"major":
				base_power = 5.0
			"minor":
				base_power = 2.0
	
	if npc.has("innocent") and npc.innocent:
		base_power *= innocent_power_multiplier
		
	return base_power

func _calculate_npc_weight(npc: Dictionary) -> float:
	var weight = 1.0
	
	if npc.has("relationship"):
		weight += npc.relationship * 0.01
	
	if npc.has("helped_player") and npc.helped_player:
		weight += 5.0
		
	return weight

func _determine_npc_special(npc: Dictionary) -> String:
	if npc.has("child") and npc.child:
		return "innocence_destroyed"
	elif npc.has("saved_by_player") and npc.saved_by_player:
		return "betrayal_of_trust"
	else:
		return "none"

func _calculate_merger_increase(target: Dictionary) -> float:
	var base_increase = 0.01
	
	match target.type:
		"companion":
			base_increase = 0.05
		"void_entity":
			base_increase = 0.1
		"reality_layer":
			base_increase = 0.08
		"self":
			base_increase = 0.2
			
	return base_increase

func _begin_apotheosis() -> void:
	# Final transformation sequence
	_world_state.trigger_apotheosis_sequence("dark")
	
	# Time accelerates
	_time_remaining = min(_time_remaining, 1)

func _get_consumed_types() -> Array:
	var types = []
	for entity in _consumed_entities:
		if not entity.type in types:
			types.append(entity.type)
	return types

func _get_consumed_ids() -> Array:
	var ids = []
	for entity in _consumed_entities:
		ids.append(entity.id)
	return ids

func _consume_entire_world() -> void:
	# The ultimate consumption
	_world_state.trigger_world_consumption()
	_total_power_accumulated = INF
	_void_merger_level = 1.0
	_reality_stability = 0.0
	_consciousness_coherence = 0.0

## Save/Load Support
func save_transition_state() -> Dictionary:
	return {
		"version": current_version,
		"consumable": _consumable_entities,
		"consumed": _consumed_entities,
		"total_power": _total_power_accumulated,
		"merger_level": _void_merger_level,
		"reality_stability": _reality_stability,
		"consciousness": _consciousness_coherence,
		"layers_consumed": _layers_consumed,
		"time_remaining": _time_remaining,
		"revelations": _revelation_stages
	}

func load_transition_state(data: Dictionary) -> void:
	current_version = data.get("version", TransitionVersion.TO_LABYRINTH)
	_consumable_entities = data.get("consumable", [])
	_consumed_entities = data.get("consumed", [])
	_total_power_accumulated = data.get("total_power", 0.0)
	_void_merger_level = data.get("merger_level", 0.0)
	_reality_stability = data.get("reality_stability", 1.0)
	_consciousness_coherence = data.get("consciousness", 1.0)
	_layers_consumed = data.get("layers_consumed", [])
	_time_remaining = data.get("time_remaining", 24)
	_revelation_stages = data.get("revelations", [false, false, false])
