# Dying Village Transition - Dragon's Labyrinth
# Harmony Path: Dread â†’ Terror
# Theme: Your compassion has limits when helping means sharing suffering

extends Node
class_name DyingVillageTransition

## Core Design: Physical touch transfers both healing AND corruption
## Revelation: The dragon was containing this plague, not causing it

signal transition_complete(outcome: Dictionary)
signal corruption_spread(target: Node, corruption_level: float)
signal villager_saved(villager: Node, cost: Dictionary)
signal horror_revealed(revelation: String)

@export_group("Transition Settings")
@export var village_name: String = "Ashenvale"
@export var initial_infected_count: int = 12
@export var corruption_spread_rate: float = 0.15
@export var healing_corruption_transfer: float = 0.3
@export var critical_corruption_threshold: float = 0.7

@export_group("Scaling Settings")
@export var companion_empathy_bonus: float = 0.2
@export var mercenary_fear_factor: float = 1.5
@export var solo_corruption_resistance: float = 0.1

var _world_state: Node
var _party_manager: Node
var _trait_system: Node
var _achievement_system: Node
var _companion_system: Node

var _infected_villagers: Array[Dictionary] = []
var _saved_villagers: Array[Dictionary] = []
var _lost_villagers: Array[Dictionary] = []
var _party_corruption: Dictionary = {}
var _revelation_stages: Array[bool] = [false, false, false]

## Three Versions of the Transition
enum TransitionVersion {
	TO_LABYRINTH,    # Journey to dragon - establishing identity
	FROM_LABYRINTH,  # After dragon's death - world changing
	SEALING_VOID     # Final desperate mission
}

@export var current_version: TransitionVersion = TransitionVersion.TO_LABYRINTH

func _ready() -> void:
	_world_state = get_node("/root/WorldState")
	_party_manager = get_node("/root/PartyManager")
	_trait_system = get_node("/root/TraitSystem")
	_achievement_system = get_node("/root/AchievementSystem")
	_companion_system = get_node("/root/CompanionSystem")
	
	_initialize_village_state()

func _initialize_village_state() -> void:
	# Generate infected villagers based on version
	match current_version:
		TransitionVersion.TO_LABYRINTH:
			_generate_plague_victims()
		TransitionVersion.FROM_LABYRINTH:
			_generate_void_corrupted()
		TransitionVersion.SEALING_VOID:
			_generate_void_conduits()
	
	# Track party corruption levels
	for member in _party_manager.get_all_members():
		_party_corruption[member.id] = 0.0

## Journey TO Labyrinth - The Dragon Plague
func _generate_plague_victims() -> void:
	for i in range(initial_infected_count):
		var villager = {
			"id": "villager_" + str(i),
			"name": _generate_villager_name(),
			"corruption": randf_range(0.2, 0.6),
			"symptoms": _get_plague_symptoms(randf()),
			"story": _generate_sob_story(),
			"can_be_saved": randf() > 0.3,
			"corruption_cost": randf_range(0.1, 0.3)
		}
		_infected_villagers.append(villager)

func start_transition() -> void:
	_show_village_arrival()
	
	match current_version:
		TransitionVersion.TO_LABYRINTH:
			_begin_plague_scenario()
		TransitionVersion.FROM_LABYRINTH:
			_begin_corruption_scenario()
		TransitionVersion.SEALING_VOID:
			_begin_void_scenario()

## The Core Mechanic: Touch Transfers Both Healing and Corruption
func attempt_healing(villager: Dictionary, healer: Node) -> Dictionary:
	var result = {
		"success": false,
		"corruption_gained": 0.0,
		"villager_state": "",
		"healer_effects": []
	}
	
	# Calculate healing chance based on healer's traits
	var healing_power = _calculate_healing_power(healer)
	var corruption_resistance = _calculate_corruption_resistance(healer)
	
	# The terrible choice: help and be corrupted, or preserve strength
	if randf() < healing_power and villager.can_be_saved:
		result.success = true
		result.villager_state = "stabilized"
		_saved_villagers.append(villager)
		
		# But healing ALWAYS spreads corruption
		var corruption_gained = villager.corruption_cost * (1.0 - corruption_resistance)
		_party_corruption[healer.id] += corruption_gained
		result.corruption_gained = corruption_gained
		
		# Healer gains empathy but suffers
		_trait_system.add_trait(healer, "plague_touched")
		if _party_corruption[healer.id] > 0.5:
			result.healer_effects.append("void_visions")
			healer.add_status_effect("hallucinating")
	else:
		result.villager_state = "beyond_help"
		_lost_villagers.append(villager)
		
		# Still gain some corruption from attempting
		var minor_corruption = villager.corruption_cost * 0.3
		_party_corruption[healer.id] += minor_corruption
		result.corruption_gained = minor_corruption
	
	# Check for revelation triggers
	_check_revelation_progress()
	
	corruption_spread.emit(healer, _party_corruption[healer.id])
	return result

## The Horror: Realization of What's Happening
func _check_revelation_progress() -> void:
	# First revelation: Plague gets worse closer to dragon
	if not _revelation_stages[0] and _saved_villagers.size() >= 3:
		_reveal_truth(0, "The saved villagers whisper: 'It gets worse... the closer you get to the mountain...'")
		_revelation_stages[0] = true
	
	# Second revelation: Dragon might be containing it
	if not _revelation_stages[1] and _party_corruption.values().max() > 0.5:
		_reveal_truth(1, "In your corruption-induced visions, you see the dragon's massive form holding back a tide of darkness...")
		_revelation_stages[1] = true
	
	# Third revelation: You're making it worse
	if not _revelation_stages[2] and _lost_villagers.size() > _saved_villagers.size():
		_reveal_truth(2, "A dying elder gasps: 'The dragon... protects... when it dies... we all...'")
		_revelation_stages[2] = true

func _reveal_truth(stage: int, revelation: String) -> void:
	horror_revealed.emit(revelation)
	_achievement_system.trigger_achievement("truth_seeker_" + str(stage))
	
	# Update world state with revelation
	_world_state.add_revelation("dying_village", stage, revelation)

## Harmony Mechanic: Emotional Bonds Affect Corruption
func _calculate_healing_power(healer: Node) -> float:
	var base_power = 0.4
	
	# Harmony traits increase healing
	if _trait_system.has_trait(healer, "empathetic"):
		base_power += 0.2
	if _trait_system.has_trait(healer, "healer"):
		base_power += 0.15
	
	# Companions provide emotional support
	var companion_bonus = 0.0
	for companion in _companion_system.get_active_companions():
		if companion.bond_level > 50:
			companion_bonus += companion_empathy_bonus
	
	return base_power + companion_bonus

func _calculate_corruption_resistance(healer: Node) -> float:
	var base_resistance = 0.2
	
	# Some traits provide resistance
	if _trait_system.has_trait(healer, "pure_hearted"):
		base_resistance += 0.2
	if _trait_system.has_trait(healer, "void_touched"):
		base_resistance -= 0.1  # Already corrupted are more vulnerable
	
	# Solo players get minor resistance bonus (they need it)
	if _party_manager.get_party_size() == 1:
		base_resistance += solo_corruption_resistance
	
	return clamp(base_resistance, 0.0, 0.8)

## The Choice: Save Some or Preserve Party Strength
func make_critical_choice() -> void:
	var choice_options = []
	
	# Option 1: Try to save everyone (high corruption cost)
	choice_options.append({
		"id": "save_all",
		"text": "We help everyone we can, no matter the cost",
		"corruption_cost": 0.8,
		"villagers_saved": _infected_villagers.size() * 0.7,
		"trait_gained": "boundless_compassion"
	})
	
	# Option 2: Save some, preserve strength
	choice_options.append({
		"id": "save_some", 
		"text": "We help who we can, but must preserve our strength",
		"corruption_cost": 0.4,
		"villagers_saved": _infected_villagers.size() * 0.4,
		"trait_gained": "pragmatic_healer"
	})
	
	# Option 3: Preserve party completely (but villagers die)
	choice_options.append({
		"id": "preserve_strength",
		"text": "We cannot risk infection. The dragon must be stopped.",
		"corruption_cost": 0.1,
		"villagers_saved": 0,
		"trait_gained": "hardened_heart"
	})
	
	# Present choice to player
	_world_state.present_major_choice(choice_options, self, "_on_choice_made")

func _on_choice_made(choice: Dictionary) -> void:
	# Apply corruption to party
	for member in _party_manager.get_all_members():
		_party_corruption[member.id] += choice.corruption_cost
		
		if _party_corruption[member.id] > critical_corruption_threshold:
			member.add_permanent_effect("void_sight")
			member.add_permanent_effect("plague_nightmares")
	
	# Save or lose villagers based on choice
	var saved_count = int(choice.villagers_saved)
	for i in range(saved_count):
		if i < _infected_villagers.size():
			_saved_villagers.append(_infected_villagers[i])
	
	# Grant trait based on choice
	_trait_system.add_trait(_party_manager.get_player(), choice.trait_gained)
	
	# Complete transition
	_complete_transition(choice.id)

## Journey FROM Labyrinth - Everyone is Corrupted Now
func _begin_corruption_scenario() -> void:
	# Dragon's death accelerated corruption exponentially
	for villager in _saved_villagers:
		villager.corruption = 1.0
		villager.transformation = "void_touched"
		villager.remembers_you = true
	
	# They beg for mercy killing
	_present_mercy_choice()

func _present_mercy_choice() -> void:
	var choices = [
		{
			"id": "grant_mercy",
			"text": "End their suffering with mercy",
			"trait": "angel_of_death"
		},
		{
			"id": "seek_cure",
			"text": "There must be another way",
			"trait": "desperate_hope"
		}
	]
	
	_world_state.present_major_choice(choices, self, "_on_mercy_choice")

## Sealing the Void - Village as Ground Zero
func _begin_void_scenario() -> void:
	# Corrupted villagers are now void conduits
	for villager in _infected_villagers:
		villager.void_conduit = true
		villager.seal_requirement = _determine_seal_method()
	
	# Use bonds formed earlier to contain outbreak
	_initiate_sealing_ritual()

func _complete_transition(outcome_id: String) -> void:
	var outcome = {
		"transition": "dying_village",
		"path": "harmony",
		"choice": outcome_id,
		"villagers_saved": _saved_villagers.size(),
		"party_corruption": _party_corruption,
		"revelations": _revelation_stages,
		"world_changes": _calculate_world_changes()
	}
	
	# Permanent world changes
	_apply_permanent_changes(outcome)
	
	# Signal completion
	transition_complete.emit(outcome)

func _calculate_world_changes() -> Array:
	var changes = []
	
	if _saved_villagers.size() > 8:
		changes.append("dying_village_becomes_haven")
		changes.append("survivors_spread_hope")
	elif _saved_villagers.size() < 3:
		changes.append("dying_village_abandoned")
		changes.append("plague_spreads_unchecked")
	
	if _party_corruption.values().max() > 0.7:
		changes.append("party_forever_changed")
		changes.append("void_visions_permanent")
	
	return changes

func _apply_permanent_changes(outcome: Dictionary) -> void:
	# Update world state
	_world_state.set_village_state(village_name, outcome.choice)
	
	# Mark which NPCs remember your choice
	for villager in _saved_villagers:
		_world_state.mark_npc_memory(villager.id, "saved_by_player", true)
	
	for villager in _lost_villagers:
		_world_state.mark_npc_memory(villager.id, "abandoned_by_player", true)
	
	# Companions remember this horror
	for companion in _companion_system.get_active_companions():
		if _party_corruption[companion.id] > 0.5:
			companion.add_memory("plague_horror", outcome)
			companion.trust_modifier -= 10

## Helper Functions
func _generate_villager_name() -> String:
	var first_names = ["Mara", "Thom", "Elsa", "Gared", "Nina", "Old Erik", "Little Ana"]
	var last_names = ["Ashwood", "Grimm", "Hollow", "Shade", "Morrow", "Wither"]
	return first_names[randi() % first_names.size()] + " " + last_names[randi() % last_names.size()]

func _get_plague_symptoms(severity: float) -> Array:
	var symptoms = []
	if severity > 0.2:
		symptoms.append("void_whispers")
	if severity > 0.4:
		symptoms.append("shadow_veins")
	if severity > 0.6:
		symptoms.append("reality_flickers")
	if severity > 0.8:
		symptoms.append("fading_from_existence")
	return symptoms

func _generate_sob_story() -> String:
	var stories = [
		"My children... they're all I have left...",
		"I was going to be married next spring...",
		"Please, I just want to see one more sunrise...",
		"The voices... they won't stop... make them stop...",
		"I can feel myself disappearing... am I still real?"
	]
	return stories[randi() % stories.size()]

## Save/Load Support
func save_transition_state() -> Dictionary:
	return {
		"version": current_version,
		"infected": _infected_villagers,
		"saved": _saved_villagers,
		"lost": _lost_villagers,
		"corruption": _party_corruption,
		"revelations": _revelation_stages
	}

func load_transition_state(data: Dictionary) -> void:
	current_version = data.get("version", TransitionVersion.TO_LABYRINTH)
	_infected_villagers = data.get("infected", [])
	_saved_villagers = data.get("saved", [])
	_lost_villagers = data.get("lost", [])
	_party_corruption = data.get("corruption", {})
	_revelation_stages = data.get("revelations", [false, false, false])
