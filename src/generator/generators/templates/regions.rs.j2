use bevy::prelude::*;

#[derive(Component, Debug, Clone)]
pub struct Region {
    pub name: String,
    pub dominant_biome: BiomeType,
    pub biome_distribution: Vec<(BiomeType, u32)>,
    pub corruption_level: u32,
    pub total_hexes: u32,
    pub settlement_density: f32,
    pub connectivity_score: f32,
    pub infrastructure_features: InfrastructureFeatures,
}

#[derive(Debug, Clone, PartialEq)]
pub enum BiomeType {
    WetMeadow,
    AshenForest,
    FloodedVillage,
    BlackSwamp,
    FungalCathedral,
    RustPlains,
    FamineFields,
    BoneForest,
    DragonScar,
    AbyssalChasm,
    // Legacy biomes
    Forest,
    Desert,
    Mountain,
    Plains,
    Swamp,
    Tundra,
}

#[derive(Debug, Clone)]
pub struct InfrastructureFeatures {
    pub rivers: u32,
    pub trails: u32,
    pub harbors: u32,
    pub borders: u32,
    pub bridges: u32,
    pub roads: u32,
}

impl Region {
    {% for region in regions -%}
    pub fn {{ region.rust_name }}() -> Self {
        Region {
            name: "{{ region.name }}".to_string(),
            dominant_biome: BiomeType::{{ region.dominant_biome_rust }},
            biome_distribution: vec![{{ region.biome_distribution_rust }}],
            corruption_level: {{ region.corruption_level }},
            total_hexes: {{ region.total_hexes }},
            settlement_density: {{ region.settlement_density }},
            connectivity_score: {{ region.connectivity_score }},
            infrastructure_features: InfrastructureFeatures {
                rivers: {{ region.rivers }},
                trails: {{ region.trails }},
                harbors: {{ region.harbors }},
                borders: {{ region.borders }},
                bridges: {{ region.bridges }},
                roads: {{ region.roads }},
            },
        }
    }
    {% endfor %}
}

// Region-specific systems
pub fn spawn_regions(mut commands: Commands) {
    {% for region in regions -%}
    commands.spawn((
        Region::{{ region.rust_name }}(),
        BiomeSpawner {
            hex_spawn_count: {{ region.total_hexes }},
            settlement_spawn_points: {{ region.settlement_count }},
            corruption_intensity: {{ region.corruption_intensity }},
        },
    ));
    {% endfor %}
}

pub fn update_regional_corruption(
    mut regions: Query<&mut Region>,
    player_distance: Res<PlayerDistance>,
) {
    for mut region in regions.iter_mut() {
        // Apply distance-based corruption to regions
        let base_corruption = region.corruption_level;
        let distance_corruption = player_distance.corruption_level();
        
        // Regions with high connectivity resist corruption better
        let resistance_factor = region.connectivity_score;
        let effective_corruption = distance_corruption as f32 * (1.0 - resistance_factor * 0.3);
        
        region.corruption_level = base_corruption.saturating_add(effective_corruption as u32);
    }
}

pub fn spawn_biome_hexes(
    regions: Query<&Region>,
    mut commands: Commands,
    mut spawned: Local<bool>,
) {
    if *spawned {
        return;
    }
    *spawned = true;
    
    for region in regions.iter() {
        // Spawn hex tiles based on region biome distribution
        for (biome_type, count) in &region.biome_distribution {
            for i in 0..*count {
                let hex_q = (i % 10) as i32;  // Distribute in 10x grid
                let hex_r = (i / 10) as i32;
                
                commands.spawn(HexTile {
                    q: hex_q,
                    r: hex_r,
                    biome: format!("{:?}", biome_type).to_lowercase(),
                    distance_band: calculate_distance_band(hex_q, hex_r),
                });
            }
        }
    }
}

#[derive(Component, Debug, Clone)]
pub struct BiomeSpawner {
    pub hex_spawn_count: u32,
    pub settlement_spawn_points: u32,
    pub corruption_intensity: f32,
}

fn calculate_distance_band(q: i32, r: i32) -> String {
    let distance = ((q * q + r * r + q * r) as f32).sqrt();
    match distance as u32 {
        0..=20 => "peace".to_string(),
        21..=40 => "unease".to_string(),
        41..=60 => "dread".to_string(),
        61..=120 => "terror".to_string(),
        _ => "horror".to_string(),
    }
}
