"""
CoreSpecification Compiler - Bridge from AI specifications to actual Python code.

This module compiles CoreSpecification objects (generated by AI workflows) into
actual working Python code using our template/pattern system.
"""

from typing import Any
from pathlib import Path
from datetime import datetime

from professor_pixel.base import BaseComponent
from professor_pixel.models import CoreSpecification, PatternSuggestion
from professor_pixel.database import pattern_db


class CoreSpecificationCompiler(BaseComponent):
    """Compiles CoreSpecification objects to actual Python code."""
    
    def __init__(self, output_directory: str | Path = "generated_core", **kwargs):
        super().__init__(**kwargs)
        self.output_directory = Path(output_directory)
        self.output_directory.mkdir(parents=True, exist_ok=True)
    
    def compile_specification(self, spec: CoreSpecification) -> dict[str, Any]:
        """
        Compile a CoreSpecification to actual Python code.
        
        Args:
            spec: CoreSpecification object generated by AI workflow
            
        Returns:
            Compilation result with generated code and file paths
        """
        self.log_info(f"Compiling CoreSpecification: {spec.component_id}")
        
        # Validate specification before compilation
        is_valid, validation_errors = spec.validate_specification()
        if not is_valid:
            self.log_error(f"Specification validation failed: {', '.join(validation_errors)}")
            return {
                "success": False,
                "errors": validation_errors,
                "component_id": spec.component_id
            }
        
        try:
            # Generate Python code using our pattern-based approach
            generated_code = self._generate_code_from_specification(spec)
            
            # Write the generated code to files
            output_files = self._write_generated_files(spec, generated_code)
            
            # Validate that generated code is syntactically correct
            validation_result = self._validate_generated_code(output_files)
            
            self.log_success(f"Successfully compiled {spec.component_id} to {len(output_files)} files")
            
            return {
                "success": True,
                "component_id": spec.component_id,
                "component_type": spec.component_type,
                "generated_files": output_files,
                "code_validation": validation_result,
                "patterns_compiled": len(spec.patterns_used),
                "assets_integrated": len(spec.core_assets_used),
                "interactive_areas": len(spec.interactive_areas),
                "compilation_time": datetime.now().isoformat()
            }
            
        except Exception as e:
            self.log_error(f"Compilation failed for {spec.component_id}: {e}")
            return {
                "success": False,
                "error": str(e),
                "component_id": spec.component_id
            }
    
    def _generate_code_from_specification(self, spec: CoreSpecification) -> str:
        """Generate Python code from CoreSpecification using pattern-based templates."""
        
        self.log_info(f"Generating code for {spec.component_type} component")
        
        # Start with base template for the component type
        if spec.component_type == "main_menu":
            code = self._generate_main_menu_class(spec)
        elif spec.component_type == "title_screen":
            code = self._generate_title_screen_class(spec)
        else:
            # Generic component template
            code = self._generate_generic_component_class(spec)
        
        return code
    
    def _generate_main_menu_class(self, spec: CoreSpecification) -> str:
        """Generate main menu class code using pattern-based approach."""
        
        # Extract assets and their metadata
        background_asset = spec.core_assets_used.get("background")
        image_map_asset = spec.core_assets_used.get("image_map") 
        professor_asset = spec.core_assets_used.get("professor_video")
        trophy_asset = spec.core_assets_used.get("trophy")
        font_asset = spec.core_assets_used.get("font")
        
        # Extract interactive areas
        interactive_areas = spec.interactive_areas
        
        # Generate asset loading code
        background_code = self._generate_background_loading_code(background_asset)
        image_map_code = self._generate_image_map_loading_code(image_map_asset)
        professor_code = self._generate_professor_asset_code(professor_asset)
        trophy_code = self._generate_trophy_loading_code(trophy_asset)
        font_code = self._generate_font_loading_code(font_asset)
        
        # Generate interactive areas and click handlers
        interactive_areas_dict = self._generate_interactive_areas_dict(interactive_areas)
        click_handlers = self._generate_click_handlers(interactive_areas)
        
        # Generate the Python class using our intelligent template approach
        code_template = f'''"""
AI-Generated Main Menu - Professor Pixel's Arcade Academy
Generated at: {datetime.now().isoformat()}
Component ID: {spec.component_id}

Generated using CoreSpecification with {len(spec.patterns_used)} patterns:
{spec.patterns_used}
"""

import arcade
import time
from pathlib import Path
from typing import Any

from professor_pixel.base import BaseComponent
from professor_pixel.models import UIRectangle, UICoordinate
from professor_pixel.settings import get_settings


class AIGeneratedMainMenuView(arcade.View, BaseComponent):
    """
    AI-generated main menu with pattern-based functionality.
    
    This class was generated from a CoreSpecification using our AI workflow system.
    It demonstrates the complete pipeline: assets â†’ patterns â†’ specification â†’ code.
    """
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.setup_core_assets()
        self.setup_interactive_areas()
        self.setup_layouts()
        self.setup_state()
    
    def setup_core_assets(self):
        """Load all core assets based on AI-analyzed metadata."""
        settings = get_settings()
        core_assets_path = settings.paths.library_dir.parent / "core"
        
        # Background (AI-selected for main menu)
        {background_code}
        
        # Image map with interactive areas (AI-parsed coordinates)
        {image_map_code}
        
        # Professor video (AI-selected intro video)
        {professor_code}
        
        # Trophy for trophy case (AI-selected resource)
        {trophy_code}
        
        # UI font (AI-selected retro pixel font)
        {font_code}
    
    def setup_interactive_areas(self):
        """Setup interactive areas from AI-parsed image map metadata."""
        self.interactive_areas = {{
{interactive_areas_dict}
        }}
    
    def setup_layouts(self):
        """Setup layout sections based on AI-generated specifications."""
        # Trophy case layout (top section)
        self.trophy_case_layout = {spec.layout_sections.get("trophy_case", {})}
        
        # Professor section layout (left center)
        self.professor_layout = {spec.layout_sections.get("professor_section", {})}
        
        # Save slot layout (bottom section)
        self.save_slot_layout = {spec.layout_sections.get("save_slots", {})}
    
    def setup_state(self):
        """Initialize component state."""
        self.selected_slot_index = 0
        self.save_slots = []
        self.video_playing = False
        self.video_finished = False
        self.load_save_slots()
    
    def load_save_slots(self):
        """Load available save slots from XDG state directory."""
        settings = get_settings()
        save_dir = settings.paths.state_dir / "saves"
        
        if save_dir.exists():
            self.save_slots = [save_file.stem for save_file in save_dir.glob("*.json")]
        
        self.log_info(f"Loaded {{len(self.save_slots)}} save slots")
    
    def on_draw(self):
        """Render the main menu using AI-generated layout specifications."""
        self.clear()
        
        # Render background
        self._draw_background()
        
        # Render trophy case (if trophies exist)
        self._draw_trophy_case()
        
        # Render professor section
        self._draw_professor_section()
        
        # Render interactive image map
        self._draw_image_map()
        
        # Render save slot selection
        self._draw_save_slots()
    
    def _draw_background(self):
        """Draw the AI-selected background."""
        if hasattr(self, 'background_texture'):
            window = arcade.get_window()
            self.background_texture.draw_sized(
                window.width // 2,
                window.height // 2,
                window.width,
                window.height
            )
    
    def _draw_trophy_case(self):
        """Draw trophy case based on AI layout specifications."""
        # AI-generated trophy case rendering logic
        if hasattr(self, 'trophy_texture') and self.trophy_case_layout:
            # Implementation based on AI layout specs
            pass
    
    def _draw_professor_section(self):
        """Draw professor video section based on AI specifications.""" 
        if hasattr(self, 'professor_video_path') and self.professor_layout:
            # Implementation based on AI professor specs
            pass
    
    def _draw_image_map(self):
        """Draw the AI-parsed interactive image map."""
        if hasattr(self, 'image_map_texture'):
            window = arcade.get_window()
            self.image_map_texture.draw_sized(
                window.width // 2,
                window.height // 2,
                self.image_map_texture.width,
                self.image_map_texture.height
            )
    
    def _draw_save_slots(self):
        """Draw save slot selection using AI font specifications."""
        if hasattr(self, 'ui_font') and self.save_slot_layout:
            # Implementation based on AI save slot specs
            pass
    
    def on_mouse_press(self, x: int, y: int, button: int, modifiers: int):
        """Handle mouse clicks on AI-generated interactive areas."""
{click_handlers}
    
    def on_key_press(self, key: int, modifiers: int):
        """Handle keyboard navigation based on AI specifications."""
        if key == arcade.key.UP and self.selected_slot_index > 0:
            self.selected_slot_index -= 1
        elif key == arcade.key.DOWN and self.selected_slot_index < len(self.save_slots) - 1:
            self.selected_slot_index += 1
        elif key == arcade.key.ENTER:
            self.load_selected_save_slot()
    
    def load_selected_save_slot(self):
        """Load the currently selected save slot."""
        if self.save_slots and 0 <= self.selected_slot_index < len(self.save_slots):
            selected_save = self.save_slots[self.selected_slot_index]
            self.log_info(f"Loading save slot: {{selected_save}}")
            # Transition to lesson/game loading
    
    def handle_start_button_click(self):
        """Handle start new game button click (AI-generated handler)."""
        self.log_info("Starting new academy enrollment")
        # Transition to enrollment workflow
    
    def handle_continue_button_click(self):
        """Handle continue game button click (AI-generated handler)."""
        self.log_info("Continuing existing save")
        self.load_selected_save_slot()


# AI-Generated component registration
def create_ai_main_menu_view(**kwargs) -> AIGeneratedMainMenuView:
    """Factory function for AI-generated main menu."""
    return AIGeneratedMainMenuView(**kwargs)
'''
        
        return code_template
    
    def _generate_background_loading_code(self, background_asset: dict[str, Any] | None) -> str:
        """Generate background loading code from asset metadata."""
        if not background_asset:
            return "# No background asset available"
        
        return f'''self.background_texture = arcade.load_texture(
            str(core_assets_path / "{background_asset['path']}")
        )
        self.log_info("Loaded background: {background_asset['display_name']}")'''
    
    def _generate_image_map_loading_code(self, image_map_asset: dict[str, Any] | None) -> str:
        """Generate image map loading code from asset metadata."""
        if not image_map_asset:
            return "# No image map asset available"
        
        return f'''self.image_map_texture = arcade.load_texture(
            str(core_assets_path / "{image_map_asset['path']}")
        )
        self.log_info("Loaded image map: {image_map_asset['display_name']}")'''
    
    def _generate_professor_asset_code(self, professor_asset: dict[str, Any] | None) -> str:
        """Generate professor asset code from metadata."""
        if not professor_asset:
            return "# No professor asset available"
        
        return f'''self.professor_video_path = str(core_assets_path / "{professor_asset['path']}")
        self.log_info("Loaded professor video: {professor_asset['display_name']}")'''
    
    def _generate_trophy_loading_code(self, trophy_asset: dict[str, Any] | None) -> str:
        """Generate trophy loading code from asset metadata."""
        if not trophy_asset:
            return "# No trophy asset available"
        
        return f'''self.trophy_texture = arcade.load_texture(
            str(core_assets_path / "{trophy_asset['path']}")
        )
        self.log_info("Loaded trophy texture: {trophy_asset['display_name']}")'''
    
    def _generate_font_loading_code(self, font_asset: dict[str, Any] | None) -> str:
        """Generate font loading code from asset metadata.""" 
        if not font_asset:
            return "# No font asset available"
        
        return f'''# UI font for save slot text rendering
        self.ui_font_path = str(core_assets_path / "{font_asset['path']}")
        self.log_info("Loaded UI font: {font_asset['display_name']}")'''
    
    def _generate_interactive_areas_dict(self, interactive_areas: list[dict[str, Any]]) -> str:
        """Generate interactive areas dictionary from AI-parsed coordinates."""
        area_lines = []
        
        for area in interactive_areas:
            area_name = area['name'].replace(' ', '_').lower()
            bounds = area['bounds']
            top_left = bounds['top_left']
            bottom_right = bounds['bottom_right']
            
            area_lines.append(f'''            "{area_name}": {{
                "bounds": UIRectangle(
                    top_left=UICoordinate(x={top_left['x']}, y={top_left['y']}),
                    bottom_right=UICoordinate(x={bottom_right['x']}, y={bottom_right['y']})
                ),
                "action": "{area['action_type']}",
                "data": {area['action_data']}
            }},''')
        
        return '\n'.join(area_lines)
    
    def _generate_click_handlers(self, interactive_areas: list[dict[str, Any]]) -> str:
        """Generate click handler code for interactive areas."""
        handler_lines = []
        
        for area in interactive_areas:
            area_name = area['name'].replace(' ', '_').lower() 
            handler_name = f"handle_{area_name}_click"
            
            handler_lines.append(f'''        # AI-generated click handler for {area['name']}
        area_info = self.interactive_areas.get("{area_name}")
        if area_info and area_info["bounds"].contains_point(x, y):
            self.{handler_name}()
            return''')
        
        return '\n'.join(handler_lines)
    
    def _generate_generic_component_class(self, spec: CoreSpecification) -> str:
        """Generate generic component class for non-main-menu components."""
        
        return f'''"""
AI-Generated {spec.component_type.title()} Component
Generated at: {datetime.now().isoformat()}
Component ID: {spec.component_id}
"""

import arcade
from professor_pixel.base import BaseComponent


class AIGenerated{spec.component_type.title().replace('_', '')}View(arcade.View, BaseComponent):
    """AI-generated {spec.component_type} component."""
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.setup_component()
    
    def setup_component(self):
        """Setup component based on AI specification."""
        # Implementation based on patterns: {spec.patterns_used}
        pass
    
    def on_draw(self):
        """Render the component."""
        self.clear()
        # AI-generated rendering logic here
        pass
'''
    
    def _write_generated_files(self, spec: CoreSpecification, code: str) -> list[str]:
        """Write generated code to output files."""
        
        output_files = []
        
        for output_file in spec.output_files:
            file_path = self.output_directory / output_file
            
            # Write the generated code
            file_path.write_text(code, encoding="utf-8")
            output_files.append(str(file_path))
            
            self.log_info(f"Generated file: {file_path}")
        
        return output_files
    
    def _validate_generated_code(self, file_paths: list[str]) -> dict[str, Any]:
        """Validate that generated code is syntactically correct."""
        
        validation_results = {
            "syntax_valid": True,
            "import_errors": [],
            "files_validated": len(file_paths)
        }
        
        for file_path in file_paths:
            try:
                # Test syntax by compiling
                with open(file_path, 'r') as f:
                    code = f.read()
                
                compile(code, file_path, 'exec')
                self.log_info(f"âœ… Syntax valid: {Path(file_path).name}")
                
            except SyntaxError as e:
                validation_results["syntax_valid"] = False
                validation_results["import_errors"].append(f"Syntax error in {file_path}: {e}")
                self.log_error(f"âŒ Syntax error in {Path(file_path).name}: {e}")
            
            except Exception as e:
                validation_results["import_errors"].append(f"Error validating {file_path}: {e}")
                self.log_warning(f"âš ï¸ Validation warning for {Path(file_path).name}: {e}")
        
        return validation_results
    
    def compile_and_test(self, spec: CoreSpecification) -> dict[str, Any]:
        """
        Compile specification and test the generated code.
        
        This is the complete end-to-end test of our AI-generated runtime system.
        """
        self.log_info(f"ðŸ¤– AI-POWERED COMPILATION: {spec.component_id}")
        
        # Compile the specification
        compilation_result = self.compile_specification(spec)
        
        if not compilation_result["success"]:
            return compilation_result
        
        # Test that we can import the generated code
        try:
            generated_files = compilation_result["generated_files"]
            
            for file_path in generated_files:
                # Try to import the generated module
                import importlib.util
                
                module_name = Path(file_path).stem
                spec_import = importlib.util.spec_from_file_location(module_name, file_path)
                
                if spec_import and spec_import.loader:
                    module = importlib.util.module_from_spec(spec_import)
                    spec_import.loader.exec_module(module)
                    
                    self.log_success(f"âœ… Successfully imported generated module: {module_name}")
                    
                    # Check for expected classes
                    if hasattr(module, 'AIGeneratedMainMenuView'):
                        self.log_success("âœ… AIGeneratedMainMenuView class found in generated code")
                    
                    compilation_result["import_test"] = "success"
                else:
                    compilation_result["import_test"] = "failed_to_create_spec"
            
        except Exception as e:
            self.log_error(f"âŒ Import test failed: {e}")
            compilation_result["import_test"] = f"error: {e}"
        
        return compilation_result


def create_core_compiler(output_directory: str = "generated_core") -> CoreSpecificationCompiler:
    """Factory function to create a CoreSpecification compiler."""
    return CoreSpecificationCompiler(output_directory=output_directory)
